Блок питания
============

Программный интерфейс блока питания
-----------------------------------


Основные функции блока питания (мониторинг заряда батареи, напряжение) поддерживается стандартными подсистемами Linux в в рамках TODO.
Однако для специфических функций: включение/отключение каналов, мониторинг событий требуются специальные компоненты.

Специфические функции включают 
(TODO нужен полный список):
* логические операции (снятие/установка битов): активация каналов питания.
* события: замыкания в каналах питания.
Доступ к ним осуществляется, как набору к регистров по i2c.

### Требования к подсистеме

Предполагается, что система должна предоставлять следующие функции: 

1. Инициализация оборудования (GPIO). Должна происходит как можно быстрее.

2. Мониторинг событий и журналирование

    * события --- необходимы для диагностики неиспраностей.
	* операции смены состояний --- для отладки взаимодействия с системой питания. 
    
	Отдельный вопрос, в какой подсистеме журналирования ROS console или syslog. Журнал ROS активен только, когда запущены компонеты компоненты ROS, т.е. не все время.
	Его логи доступны с машины оператора и связаны по времени с остальными событими. 
	syslog активен постоянно, но отладка через него представляется неудобной для ROS системы.

3. Прикладной интерфейс для ROS компонент. Необходим, если требуется более сложная логика управления, чем однократный запуск bash-скрипта при развертывании системы. 
	
    Желательна возможность использования из python, т.к. соответвующая логика выненсена в высокоуровневую часть системы, которая в настоящий момент реализована на нем.
	Однако, если интерфейс вынесен в отдельный компонент со стандартным интерфейсом ROS, то язык реалзации не важен.

	По функцианалу интерфейс может включать: 
	* операции по запросу состояния (чтение регистров/битов) --- сервис ROS
	* операции по изменению состоя (запись регистров/битов) --- сервис ROS
	* уведомление о событиях --- публикация топика ROS.

	На текущий момент, не ясно, насколько важна обработка событий. Может и должна ли система управления роботом адекватно реагировать на события блока питания? 
	Для ответа на этот вопрос нужен полный список событий. 
	Полная авариная остановка всей системы управления роботом --- нетривиальная задача изнутри отдельного компонента. 
	Разумной реакцие на аварию, явлется остановка текущего жействия и нотификация пользователя при помощи голосовой подсистемы.
	В минимальной реализации эти события можно просто игнрировать.

	Тот же вопрос касается операций и запроса состояний. Выключать каналы питания нужно для экономии энергии, т.е. при переходе в режим "сна".
	Однако минимальная реализация включает только активацию нужных систем при запуске робота и их отключение при остановке. 
	Она может быть решена без специального интерфейса, посредством запуска утилиты CLI из roslaunch.

4. Интерфейс командной строки для ручного управления или из скриптов развертки. Представляет собой утилиту с набором команд (запрос состояние, запись регистров и битов, журнал событий (излишен)).

5. Прикладной интерфейс для не ROS программ. Необходим, если предполагается стороннее использование блока питания. 
    По функциональности должен повторять интерфейс ROS.

6. Поддержка множественного доступа. Поддержка прав доступа? 


### Варианты исполнения

## Минимальный набор утилит

Система реализуется как набор скриптов bash/python, использующих стандартные библиотеки для взаимодействия с i2c. Первичная инициализация выполняется запуском скрипта через udev, 
подсистема журналирования отсутствует, события можно проверять только мониторингом (poll) путем вызова утилит. Множественный доступ и контроль доступа решается на уровне подсистемы i2c.

*Плюсы*: 
* быстрота и простота реализации
* возможность интеграции с roslaunch

*Минусы*:
* отсутствие журнала, 
* невозможность реагировать на события,
* невозможность интеграции в код компонентов ROS.

## Библиотека C/C++ и набор утилит

Ядром системы является библиотека, предоставляющая тонкую обертку над i2c. 
Она предоставляет доступ к регистрам (чтение и запись) в удобной форме и может быть использована из компонент ROS/OROCOS.
Проблема множетсвенного доступа решается на уровне i2c.
Библиотека может быть реализована на C, С++ или python.

На основе библиотеки реализуется группа утилит:
* Утилита, реализующая CLI интерфейс. Она же используется для первичной инициализации путем вызова из udev.
* Журналирующий демон. Периодически опрашивает состояние и пишет его в syslog, однако журналировать команды он не способен.
Следует отметить, что по подобной схеме в GNU/Linux реализован мониторинг smart.

Библиотека и утилиты могут быть использованы в компонентах ROS в различных вариантах:
* Запуск утилиты CLI из roslaunch для инициации на уровне ROS (включение каналов).
* Прямое обращение к функциям библиотеки из кода компонент ROS. Т.к. соответствующая логика реализуется на python, необходим ptyhon-биндинг. 
    Отслеживание состояния производится, если требуется, путем его постоянного чтения. Журналирование выполняется стандартными средствами ROS.
* Выделенный интерфейсный компонент. Он решает задачи предоставления интерфейса для конфигурации, мониторинга состояния и публикации, журналирования средствами ROS. Язык реализации неважен.

Плюсы:
* средняя сложность реализации, разделение системы на множество модулей, которые можно писать постепенно.
* реализован практически весь функционал.
* журналирование в ROS сильно упростит отладку взаимодействие с блоком питания, журналирование в syslog позволяет не упустить важные события, однако единый лог отсутствует.
Минусы:
* python-реализация выглядит медленной и не соответствует представлениям, как должны реализоваться демоны GNU/Linux.
* C/C++-реализация сложнее, для интеграции библиотеки без написания выделенного компонента может потребоваться python-биндинг.
* мониторинг состояния и событий происходит из двух мест: демона syslog и ROS-реализации интерфейса. Это подход неприменим, если чтение снимает флаги состояний. Увеличение числа обменов.


### Выделенный демон, утилита CLI, интерфейсный компонент ROS.

Ядром системы является демон. При запуске он выполняет первичную реализацию. Демон предоставляет через стандартные способы межпроцессного взаимодействия (именованный канал, очередь сообщений или сокеты)
доступ к функционалу по чтению и изменению состояний. Через этот же интефейс он может нотифицировать о событиях. Демон ведет журналирование в syslog событий и операций.
Проблема множественного доступа решается на уровне демона.

Интерфейс CLI реализуется как отдельная утилита, обращающая к демону. Интерфейс ROS реализуется в виде компонента, взаимодействующего с демоном. Он же может взять на себя функции логгирования в ROS.
Разумным выглядит создание библиотеки для удобного общения с демоном, представляющей обертку вокруг обращения к системным вызовам межпроцессного взаимодействия.
На основе этой библиотеки можно обращаться к демону из утилиты CLI, выделенного компонента ROS или просто компонент ROS.

Плюсы:
* журналирование для всех событий и команд. syslog работает постоянно, ROS console, когда запущен ROS. При правильной реализации их можно сделать полностью идентичными (ROS-лог будет фиксировать команды из CLI).
* реализован весь запрашиваемый функционал
* единственные вариант реализации, если чтение состояния приводит к сбросу флагов событий.
Минусы:
* придется реализовывать полноценную систему множественного доступа на уровне демона, она фактически дублирует уже имеющуюся реализацию для i2c.
* сложность межпроцессных взаимодействий. Так при реализации компонента ROS будет два уровня взаимодействия: клиент <-> компонент ROS <-> демон. Альтернативный вариант по приданию демону интерфейса ROS выглядит также излишне сложным.
* Для библиотеки на C/C++ потребуется python-биндинг для интеграции в компоненты ROS, написанные на python.



