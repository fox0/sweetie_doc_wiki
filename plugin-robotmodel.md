Плагин кинодинамической модели `RobotModelURDF`
=======================


Предназначен для унификации загрузки модели робота, доступа к кинематическим цепочкам и средствам именования и нумерации звеньев. 
Также он предоставляет список контактов и их модели (контакты моделируются набором неподвижных точек).

Эту функциональность используют: 

* модули кинематики, 
* динамика, 
* `agregator_gait` (версия на базе `JointLimbState`), 
* задатчики (собственная кинематика или преобразование `JointState` -> `JointLimbState`) 

Контакт предоставляет собой именованный набор неподвижных точек, что позволяет моделировать 3 типа контактов:
* точечная опора (3 степени свободы),
* фиксированная ось (1 степень свободы),
* полный контакт (нет степеней свободы).
Эта модель ограниченна, однако удовлетворяет всем основным потребностям для шагающего робота.

Динамическое добавление контактов, их модификация в процессе работы невозможна.
Контакт не привязан к какой-то либо кинематической цепочке. 
Подразумевается, что координаты даны относительно последнего звена цепочки.

### Параметры

1. `robot_description` (`string`) --- описание робота в виде URDF.
1. `kinematics_chains` (`PropertyBag`) --- структура с декларациями ресурсов-кинематических цепочек.
```
      |- chain1_name
      |  |- first_link (string) --- основание кинематической цепочки.
      |  |- last_link (string) --- ее последнее физичексое звено.
      |  |- last_link_virtual (string) --- виртуальное звено, являющееся концом цепочки. Виртуальные звенья добавлются, чтобы упростить работу алгоритмов обратной кинематики.
      |  |- default_contact (string) --- имя контакта по умолчанию.
      |  \- parameter1 (игнорируется)
      \- chain2_name
```
2. `contacts` (`PropertyBag`) --- структура с декларациями контактов
```
      |- contact1_name
      |  \- points (KDL::Vector[]) --- список неподвижных точек в СК last_frame.
      \- contact2_name
         \- points
```


### Операции (предоставляет)

Конфигурация плагина:
1. `bool isConfigured()` (`ClientThread`) --- возвращает `true`, если сервис сконфигурирован.
1. `configure()/cleanup()` (`OwnThread`) --- загрузка urdf, формирование цепочек (`chains`), очистка.

Доступ к описанию робота:
1. `string getRobotDescription()` --- возвращает URDF модель.
1. `KDL::Tree getTree()` --- возвращает модель робота (KDL). 
1. `KDL::Chain getChain(bool with_virtual_joints)` --- возвращает модель кинематической цепочки (KDL). 

Информация о кинематических цепочках
2. `strings listChains()` (`ClientThread`) --- список цепочек.
2. `int getChainIndex(string chain)` (`ClientThread`) --- номер цепочки, -1, если цепочки не существует.
3. `string getChainDefaultContact(const string& name)`  (`ClientThread`) --- возвращает имя контакта по умолчанию для данной цепочки.
3. `string getChainProperty(const string& name)`  (`ClientThread`) --- возвращает значение параметра данной цепочки: `last_link`, `first_link` and so on.

Информация о сочленениях:
4. `strings listJoints()` (`ClientThread`) --- список всех звеньев.
5. `int getJointIndex(const string& name)` (`ClientThread`) --- возвращает позицию звена в упорядоченной в соответствие с принятыми соглашения позе робота, -1 в случае ошибки.
3. `string getJointChain(const string& name)`  (`ClientThread`) --- возвращает имя цепочки-владельца звена, пустую строку, если звена нет.
3. `strings getJointsChains(strings name)`  (`ClientThread`) --- возвращает список имен цепочек владельцев звеньев.

Контакты:
4. `strings listJoints()` (`ClientThread`) --- список имен контактов.
2. `KDL::Vector[] getContactPoints(string contact)` (`ClientThread`) --- возвращает модель контакта --- список неподвижных точек.
5. `int addContactPointsToBuffer(string contct, KDL::Vector[]& buffer) --- добавить неподвижные точки в буфер.

### Детали реализации

Для ускорения работы предварительно (при конфигурации) выделяются зарегистрированные кинематические цепочки. 

Потребуется ввести атомарную переменную флаг, чтобы исключить запуск методов до завершения конфигурации. Т.к. 
после конфигурации внутренние переменные не модифицируются, то не должно быть проблем с смножественным доступом к ним.

Для удобства предлагается реализовать следующие интерфейсы:

1. `RobotModel` (`ServiceRequester`) --- для удаленного подключения.
1. `RobotModelInterface` (`Service \*`) --- внутренний интерфейс, для доступа из компонента, куда сервис загружен.

Предполагается, что будет использована минимальное число экземпляров сервиса (упрощает развертывание). 
Они загружаются только в те компоненты, которым необходим внутренний интерфейс (кинематика) и валадение сервисом.
Остальные компоненты используют его путем добавления `ServiceRequester`-а в свой интерфейс:

    // constructor
    robot_model = ServiceRequester::shared_ptr(new RobotModelSimple())
    this->requires()->addServiceRequester(robot_model)

    // configureHook
    if (robot_model.ready()) { ...

    // deployment
    connectServices(...

