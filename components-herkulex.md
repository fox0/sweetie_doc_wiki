Интерфейс приводов Herkulex
===========================

Требования
----------

Подсистема взаимодействия с приводами должна удовлетворять следующим целям:

1. Доступ к приводу по имени, преобразования внутренних единиц измерения в единицы СИ.
1. Настройки приводов: передача параметров кофигурации в память приводов.
2. Мониторинг: считывание регистров, статус привода, сброс статуса и пр. по требованию пользователя.
3. Считывание позы при инициализации системы управления, возможность ее считывания в 
3. Взаимодействие в реальном времени: периодичская посылка задания всем или группи приводов, считыание парметров заданной группы приводов.
  *Интерфейсы мониторинга и настройки не должны мешать работы интерфейса реального времени.*

Желаельно обеспечит максимальное повторное использование кода, поддержку ескольких приводов

Структура системы взаимодействия с приводами
-------------------------------------------

На основе требований выделяется и характера протокола выделяется 4 элемента:

1. Канальный уровнь : прием/посылка и проверка целостности кадров. (`herkulex_driver`)

2. Реализация уровня представления (протокол): именование, кодирование/декодирование кадров.
  Например, преобразование операции назначения/чтения параметра привода в сообщение, 
  преобразование задания на приводы в сообщение, 
  декодирование ответа привода.

  В настоящий момент он реализован в виде программных объектов типа `HerkulexServo`.

3. Подсистема реального времени: передача целевой позиции, считывание состояния (скорость, позиция и т.п.) группы приводов с заданной частотой и минимальной задержкой,
  кэширования регисров приводов и т.п.

4. Подсистема настройки: назначение произвольного набора парметров, чтение произвольного набора параметров, опрос статусов, считывание состояния группы приводов.

  В настоящий момент он реализован в виде компонента `herkulex_array`.

**Принцип разделения времени**. Система управления работатет по циклам. В начале каждого цикла подситеме РВ выделяется интервал времени, в течении которого она осуществляет обмен. 
По завершения обмена, либо по истечению времени канал передается посдсистеме настройки и мониторинга, которая использует оставшийся промежуток времени. За осуществление этого разделения 
отвечает **планировщик**.

Для реализации разделения по времени необходимо иметь верхнюю оценку на полного времени выполнения операции, включащегося в себя: подготовку сообщения, посылку, обработку на стороне клиента, посылку ответа, обработку ответа. Выполнение очередной операции не начинается, если для нее не хватает времени в выделенном интервале.

Т.к. подситема реального времени тесно связана с планировщиком, предлагается их объединитью. 

Канальный уровень вынесен в отдельный компонент. Решенние относительно спорное, т.к. при использовании операций 

### Альтернативные варианты реализации

#### Разделение интерфейса РВ и НМ

Для работы подсистемы РВ и НМ требуется реализация протокола. Однако вынести реализацию протокола в отльный компонент затруднительно из-за слишком тесной связи с обоими подсистемами.
Возможны реализации:

1. **Один компонент** для подсистемы РВ, подсистемы НМ, протокола и планировщика.
2. **Два компонента с двумя копиями протокола**:
  1. Подсистема РВ, планировщик, протокол.
  2. Подсистема НМ, протокол.
2. **Два компонента с одной копией протокола**: 
  1. Подсистема РВ, планировщик, требует операции кодирования JOG и запроса состояния, декодировани ответа на запрос состояния.
  2. Подсистема НМ, протокол, предоставляет операции кодирования JOG и запроса состояния, декодировани ответа на запрос состояния.
2. **Два статически свзанных компонента** с одной общий копией протокола:
  2. Подсистема НМ, протокол, в конструкторе создается еще одни `TaskContext` для подсистемы РВ. 
  1. Подсистема РВ, планировщик, доступ к протоколу осуществляется через ссылку на его класс. 

Первый варинат потребует нескольких нитей (`ExecutionEngine`) в одном компоненте и их ручной синхронизации. 
Фактически это будет два компонента в одной обертке.

Второй вариант приводит к двум экземплярам реализации протокола. Это означает, что часть настройки (списки приводов, аппаратные ID, параметры калибровки) должны дублироваться.
С другой стороны, могут быть параметры, используемые только в одной конфигурации.

Третий вариант осуществим только с реализацией подсистемы НМ в виде компонента OROCOS с приоритетом РВ или с версиями операций `ClientTread`.

Четвертый вариант представляет хороший компромис. Однако он предполагает специальные требования на методы протокола: потокобезопасность, 
(Вообще говоря, указатель на протокол можно передать и операцией, если компоненты исполняются в одном адресном пространстве. 
Но статическое связывание гарантирует такую ситуацию).

Далее описан **четвертый вариант**.

#### Взаимодействие с канальным уровнем

1. Канальный уровень реализуется в виде библиотки и становится частью РВ подсистемы. Обращение --- вызовы функций.
2. Канальный уровень отдельный компонент, взаимодействие синхронное --- операции. 
3. Канальный уровень отдельный компонент, взаимодействие асинхронное --- порты. 

В первых двух вариантах обращение к канальному уровню выглядит как вызов функции, блокирующийся до завершения операции. Эта способ хорошо согласуется с
текущей реализацией. Использование библиотеки быстрее, но менее универсально.

При асинхронном взаимодействии в центре будут пакеты и состояния протокола, а не операции, этот подход потенциально быстрее. 

Далее описан **вариант с операциями**.


Компонент `herkulex_driver`
----------------

Реализация канального уровня: формирование и отправка пакета по интерфейсу. 

### Входные порты

Нет.

### Выходные порты

Порт публикует пакеты, например, для целей мониторинга. Возможность опциональна.

1. `broadcast` (`HerkulexPacket`) --- последней полученный/отправленнный пакет.

### Параметры

1. `port_name` (`string`) --- имя устройства порта.
1. `baudrate` (`uint`) --- скорость передачи данных.
1. `timeout` (`uint`) --- время ожтдания ответного пакета. 

### Операции

1.	`bool request(HerkulexPacket& req, HerkulexPacket& ack)` (`OwnThread`) --- послать запрос, дождаться ответа, вернуть результат.
1.	`bool cmd(HerkulexPacket& cmd, Empty)` (`OwnThread`) --- послать команду, не ожидать ответа. 
1.	`uint estimate(uint data_size, bool ack_rek)` (`ClientTread`) --- верхняя оценка времени обмена (опционально).

### Семантика исполнения

**Конфиурация**. Открытие порта.

**request**. Синхронный запрос. Запускает таймер.  Формирует кадр по `HerkulexPacket`, посылает его, ожидает целостного кадра-ответа. 
Возврат по успеху или истечению таймера. Некорректно сформированные данные игнорируются.

**cmd**. Формирует кадр, посылает его.

**Замечание**: Компонент не осуществляет контроль за соблюдением политики ACK (следует ли ожидать ответа от привода на данный пакет). 
Соответсвующие коллизии должен предотвращаить протокол.

### Детали реализации.

Если не использовать `asio`, предлаеется завести отдельную нить `FileDescriptorActivity` для чтения. 
Разбор входа --- стандатный подход на базе конечного автомата. Автомат сбрасывается по `breakLoop`.

Взаимодействие нитей `DataObject` или `BufferLockFree` и условная переменная или светофор.

### Исключения и ошибки

**Ошибки**:
1. Аппаратные ошибки ввода-вывода.

**Предупреждения**:
2. Некорректный запрос.
3. Некорректный ответ.
3. Лишний или потерянный ответ.

Компонент `herkulex_array` 
-------------------------

Подсистема настройки и мониторинга. Загружает интерфейс и планировщик реального времени `herkulex_sched`.

### Входные порты

Отсутсвуют.

### Выходные порты

1. `joints` (`JointState`) --- позиция и скорость приводов. Опрашивается и публикуется по запросу для целей первичнй инициализации.

### Параметры

1. `servos` --- динамическая структура (`PropertyBag`) с информацией приводах в системе. Приведены основные опции.
  
      |- servo1_name
      |  |- hw_id (uint) --- идентификатор
      |  |- servo_model (string) --- модель привода
      |  |- registers_init
      |  |   \- register_name (uint) --- значения регистров, инициализируемых при запуске. 
      |  |- reverse (bool) --- флаг обращения направления на уровне протокола
      |  \- offset (double) --- смещение нуля (на уровне протокола).
      \- chain2_name

  *Открытый вопрос*: хранить регистры в `uint` или преобразовывать в СИ.

2. Число попыток обращения к приводу.

### Операции

**Внешний интерфейс настройки и мониторинга **. 

(Преимущественно `OwnTread`, в порядке важности, все не нужны).

1. `strings listRegister(servo)`
2. `uint getRegister(servo, reg)` --- (что делать с ошибочным именем?)
3. `bool setRegister(servo, reg, val)`
4. `printRegisterList(servo)`
4. `printRegisters(servo, regs)`
4. `printAllRegisters(servo)`
5. `getStatus(servo)`
5. `clearStatus(servo)`
6. `publishState(servos)` --- опросить позицию и скорость, опубликовать ее.
6. `writeRegProperties()` --- обновить значения параметров в `registers_init` текущими значениями регистров (новые не создавать).
6. `addRegProperties()` --- добавить новые пармеры, инициализировать их регистрами.
6. `readRegProperties()` --- перечитать параметры в регистры.

**Интерфейс с `herkulex_sched`**. 

1. Требует: `void request(HerkulexPacket req)` (`ClientTread`) --- извещает `herkulex_sched` через `BufferLockFree` о новом запросе. 
  После такого запроса `herkulex_array` может заблокироваться на условной переменнной.
1. Предоставляет: `void response(HerkulexPacket req)` (`ClientTread`)  записывает в `BufferLockFree` результат запроса, посылает 
  сигнал условной переменной.

Это механизм позволяет синхронный вызов функции `sendRequest` в `herkulex_array` в асинхронный запрос на уровне на обработку пакета в `BufferLockFree` в `herkulex_sched`.
Подробнее в деталях реализации.

### Методы
         
1. `sendRequest(HerkulexPacket req, HerkulexPacket ack)`  --- синхронный запрос к приводам.

### Семантика исполнения

**Конфиурация**. Считываются опции, создается `HerkulexArray`, содержащий содержащий объекты `HerkulexServo`. Проводится инициализация регистров по параметрам.

**Исполнение**. `updateHook` пуст, основной код в операциях. Операции транслируют запрос в вызовы `sendRequest`. 

В некоторой степени открыт вопрос кэширования регистров в приводов. Для ускорения операций требующий чтения множества решистров они очень желательны.

### Детали реализации.

Операции длительные и блокирующие. Следует предусмореть реализацию `breakLoop`, прерывающую ожидание (сигнализует условную переменную).

#### Взаимодействие c `herkulex_sched`

Механизм описывается псевдокодом ниже. Он позволяет обрабатывать "операцию" `sendRequest` в `updateHook` по усмотрению `herkulex_sched`.

В `herkulex_array`:

    sendRequest(HerkulexPacket req, HerkulexPacket ack) {
       request(req)
       ждаем условия
	   buffer_lock_free1.Pop(ack)
	} 
    response(HerkulexPacket ack) {
       buffer_lock_free1.Push(ack)
       сигнализуем условие
    }

В `herkulex_sched`:

	updateHook() {
    ...
    if (!buffer_lock_free2.empty()) {
       buffer_lock_free2.Pop(req)
       обработка
       response(ack)
    }
    request(HerkulexPacket req) {
       buffer_lock_free2.Push(req)
    } 

#### Реализация протокола (не завершено)

Предлагается следующая иерархия классов. Параметры конструкторов являются списками полей-данных. 
Основное требование --- неизменность описания массива приводов при функционировании компонента. 

Cемантика протокола в трансляции запросов в `HerkulexPacket` и обратном декодировании ответов в заданные структуры данных.
Иного варианта быть не может: один объект-протокол используется одновременно двумя нитями, использующми разные методы обращения к
приводам.

Однако такой подход неудобен тем, что нельзя прямо в протокол вписать последовательности действий, например, по 
инициализаци привода. Их должен исполнять неосредственно `herkulex_array`, причем трудно сделать такую последовательность 
своей для каждого привода. 


    RegisterMapper(vector<HerkulexRegister>) 
    // описание набора регистров, преоьразования адреса в имя и обратно в любом направлении.

    RegisterValues : map<string, uint> --- используется для передачи и хранения сотояния групы регистров

    HerkulexServo(name, hw_id, RegisterMapper, reverse, offset)
    // Запись о существовании привода. Не хранит никаких состояний привода. Реализует типовые операции c приводовм.
    // Связывается c RegisterMapper по ссылке.
    .convert* --- преобразование значений в СИ к внутреннему представлению привода и обратно (учет scale, reverse).
    .reqRead(HerkulexPacket& req, string register) --- запрос на чтение регистра
    .reqRead(HerkulexPacket& req, reg_start, reg_end) --- запрос на чтение регистров
    .reqRead_epp(HerkulexPacket& req, string register) --- запрос на чтение регистра
    .reqStatus(HerkulexPacket& req
    bool .ackRead(HerkulexPacket& ack, RegisterValues regs) --- декодирование запроса, false при несовпадении типа
    // Заглушки для методов чтения РВ. Не знаю, как сделать лучше: для привода с произвольным набором регистров
    // нельзя гарантировать, что нужные решистры есть и их можно прочитать за одно обращение к приводам.
    .reqPosVel --- запрос скорости и позиции
    bool .ackPosVel --- запись результата в структуру
    .reqState --- регисров регистры 53--59
    .ackState

    HerkulexServoDRS0101(name, hw_id, reverse, offset) : HerkulexServo
    // Жестко задан RegisterMapper, реализованы жестко завсящие от набора регистров методы 
    .reqPosVel --- запрос скорости и позиции
    bool .ackPosVel --- запись результата в структуру в единицах СИ
    .reqState --- регистры 53--59
    .ackState

    HerkulexArray 
    // Агрегирует набор HerkulexServo (реально HerkulexServoDRS0101)
    // доступ по имени, итерация по элементам
    .reqIJOG(HerkulexPacket& req, HerkulexGoal& goal)
    .reqSJOG(HerkulexPacket& req, HerkulexGoal& goal, playtime)


### Исключения и ошибки

Уточнить
1. Привод не отвечает на STAT
2. Превышен лимит числа попыток обращения к приводу: привод не отвечает
2. Превышен лимит числа попыток обращения к приводу: привод не вернул плохой ответ.
4. Неdthyjt bv привод/регистр.


Компонент `herkulex_sced`
--------------------------

Подсистема обмена реального времени.

### Входные порты

1. `sync` (`TimerEvent`, `EventPort`) --- тактирующий сообщения таймера
1. `goal` (`HerkulexGoal`) --- задания на приводы

### Выходные порты

1. `joints` (`JointState`) --- позиции и скорости (прочитанные).
2. `states` (`HerkulexState`) --- расширенное состояние привода.

### Параметры

1. `period_RT` (`double`) --- длительность периода РВ (секунды)
1. `period_CM` (`double`) --- длительность периода НМ (секунды)
2. `poll_list` (`strings`) --- список приводов, которые опрашиваются.

### Операции

**Интерфейс с `herkulex_array`**. 

1. Предоставляет: `void request_CM(HerkulexPacket req)` (`ClientTread`) --- извещает `herkulex_sched` через `BufferLockFree` о новом запросе. 
  После такого запроса `herkulex_array` может заблокироваться на условной переменнной.
1. Требует: `void response_CM(HerkulexPacket req)` (`ClientTread`)  записывает в `BufferLockFree` результат запроса, посылает 
  сигнал условной переменной.

**Интерфейс с `herkulex_driver`**. 

1. Требует:	`bool request(HerkulexPacket& req, HerkulexPacket& ack)` (`OwnThread`) --- послать запрос, дождаться ответа, вернуть результат.
1. Требует:	`bool cmd(HerkulexPacket& cmd, Empty)` (`OwnThread`) --- послать команду, не ожидать ответа. 
1. Требует:	`uint estimate(uint data_size, bool ack_rek)` (`ClientTread`) --- верхняя оценка времени обмена (опционально).

### Методы

### Семантика исполнения

**Исполнение**. `updateHook()`:

1. Ожидаем сообщение `TimerEvent`
2. Запускаем таймер на длительность `period_RT`
2. Читаем порт `goal`, посылаем JOG
3. В цикле читаем `poll_list` и опрашиваем приводы.
4. Выход из цикла: итек таймер или кончился список.
5. Публикуем результат опроса.
2. Запускаем таймер на длительность `period_CM`
3. В цикле ждем на условной переменной запроса через вызов `request_CP`, обрабатываем его.
4. Цикл и ожидание прерываем по истечению таймера.
5. Коннец `updateHook`

По идее, можно опросить сотосние всех приводов за несколько циклов.

### Детали реализации.

### Исключения и ошибки

Уточнить
1. `TimerEvent` пришло раньше выхода из `updateHook()`.
2. Ошибка разбора ответа привода.
3. Имена приводов.
