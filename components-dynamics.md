Динамика `dynamics_inv`
=======================

Компонент по параметрам движения (позиция, скорость, ускорение) в угловой системе координат
и распределению веса робота рассчитывает необходимые моменты приводов. 
Эта информация в дальнейшем используется, чтобы точнее формировать задания на приводы.

Использует вспомогательный класс [`RobotURDFModel`](components-kinematics).

### Входные порты

1. `joints_in` (`JointState`/`JointLimbState`, EventPort) --- состояние робота в угловой СК: позиции, скорости.
1. `support_in` (`SupportState`) --- распределение веса (только если не используется `JointLimbState`.

### Выходные порты

1. `joints_out` (`JointState`) --- состояние робота в угловой СК: позиции, скорости, моменты приводов.

### Параметры

1. `urdf_file` --- имя файла с описанием робота (реализуются вспомогательным классом).
1. `kinematics_chains` --- структура с декларациями ресурсов-кинематических цепочек (реализуются вспомогательным классом).
  
      |- chain1_name
      |  |- first_link (string)
      |  |- last_link (string)
      |  \- parameter1 (дополнительные параметры, зависят от алгоритма)
      \- chain2_name

2. Глобальные параметры решателя.

### Операции

1. `addChain(string name)`, `removeChain(string name)` добавление/удаление динамических параметров для ручного использования (вспомогательный класс). 
 Создает необходимый набор дочерних параметров цепочки (`first_link`,...). Изменяет только опции, для перенастройки требуется вызов `configure`.

### Семантика исполнения

**Конфигурация**. Загрузка модели, инициализация решателя.

**Исполнение**. Решает обратную задачу динамики (рассчитывает силы по параметрам движения), на выходе копия входного сообщения с добавлением поля `torque`.
Выполнение осуществляется по приходу нового сообщения.

Для расчета ускорения требуется дифференцировать скорость. 
Вероятно, нужны несколько вариантов дифференциаторов, их настройка и выбор осуществляется через параметры.

### Детали реализации.

Для загрузки модели используется класс `RobotURDFModel`, см. [компоненты кинематики](components-kinematics).

Код расчета производных следует выделить в отдельную [вспомогательную библиотеку](library-filters): потенциально ей могут пользоваться агрегатор и задатчики.

Ни RDBL, ни KDL не умеют решать задачу обратной динамики для дерева. Принципиально она не сложна (сводится к решению СЛАУ), коэффициенты которой может рассчитать RDBL (как для цепочек, так и для ограничений --- точек касания). 

Альтернативный вариант --- на основе `SupportState` разбить задачу на расчет каждой цепочки отдельно. Такой способ сильно зависит от точности 
оценки распределения весов, который как-то должен оценивать задатчик. Этот вариант проще и должен быть годен для небольших скоростей.

### Исключения и ошибки

Уточнить, отсортировать

1. Некорректное имя цепочки
2. Неполная поза.
3. Нарушение условий касания.
