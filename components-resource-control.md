Арбитр ресурсов
======================


Серерная часть: компонент `resources_control`
---------------------------------------------

Компонент регистрирует все задатчики, осуществляет прием запросов на ресурсы и формирование требований на осовобождение ресурсов.

Здесь описана модификация на оснве операций. Прототипы операций совместимы с сервисами ROS (спецтребование). 

### Входные порты

Отсутсвуют.

### Выходные порты



### Параметры

1. `strings list_orocos` --- список компонент-задатчиков OROCOS.
1. `strings list_ros` --- список компонент-задатчиков ROS.
1. `strings resources` --- список ресурсов (для проверки корректности запросов).

### Операции

1. Предоставляет: `bool requestResources(ResourceRequest req, bool success)`

### Семантика исполнения

**Конфигурация**. Для всех компонент из списка задатчиков проверяет  наличие операции `releaseResosurces()`.
Если нет компонента или операции `releaseResosurces()`, то конфигурация 
считается неуспешной. Иначе подключает к всем компонентам  свою операцию `requestResources()`.

**Исполнение**. По вызову `requestResources` для всех компонент из списка задатчиков, кроме пославшего запрос, 
вызывает `releaseResosurces` с полученным списком ресурсов. Потенциально число запросов можно сократить, 
если следить за мнножеством активных компонент и извещать только их.

Запрос ресурсов неудачен, если имени запрашивающего компонента (`req.name`) или какого-то из ресурсов нет в списке. 

Компонент считается активным после `requestResources()` и пока `releaseResosurces()` не вернула `true`.

**Замечание**: Поведение значительно проще, если использовать сообщения. Список не требуется, достаточно просто сделать эхо.


### Детали реализации.

Переключение может длиться долго, т.к. требует ожидания исполнения операций на всех компонентах списка.
Некоторое ускорение можно добиться асинхронным вызовом операций (`send`). 
Ожидание исполнения операций необходимо, иначе теряется синхронность переключений.



Могут возникнуть проблемы с реализацие процедуры конфигурации. 

Передача задатчиком не своего имени приведет к deadlock.

### Исключения и ошибки

Ошибки:
1. Некорректный с набор компонент при конфигурации.


Клиентская часть: абстрактный класс `ResourceConsumer`
-----------------------------------------------------

Реализует общую часть интерфейса задатчиков.

### Входные порты

Отсутсвуют.

### Выходные порты

Отсутсвуют.

### Параметры

Отсутсвуют.

### Операции

1. Требует: `bool requestResources(ResourceRequest req, bool success)`
1. Предоставляет: `bool releaseResources(ResourceRequest req, Empty)`

### Методы

1. `getResourceSet()`, `bool hasResource(const string& res)` --- проверка бладания ресурсом.
2. `bool requestExclusiveResources(const strings& resourses)` --- захватить набор ресурсов (пытается вызвать операцию requestResources()).
3. `virtual void notifyResourcesAcquire()` (реализуется в наследнике) --- извещает о успешном захвате.
4. `virtual void notifyResourcesRelease()` (реализуется в наследнике) --- извещает о осовобождении всех ресурсов.

### Семантика исполнения

**`requestExclusiveResources`**. Послать запрос, запомнить список ресурсов, вызвать `notifyResourcesAcquire()`. Если операция не готова --- неудача.

**`releaseResources`**. Проверить пересечение ресурсов компонента и полученного списка. Если пересекается, очистить список, вызвать `notifyResourcesRelease()`. 
Возвращает `true`, если компонент не активен после вызова.

### Детали реализации

Интерфейс несколько переусложнен, что связано с поддержкой алльтернативных протоколов: на основе сообщений, запросы с приоритетами.

При реализации системы переключения на базе сообщений (портов) для обработки входящих сообщений компонент должен быть запущен на этапе посылки запроса.
В этом случае требуется предовратить выпонение клиенстского кода в `updateHook()` до завершения запроса. Возможных решения два:

1. Обязать задатчик размещать свой код в методе `abstract void updateHookOperational()`.
2. Метод `bool isOperational()` и обязать код задатчика делать проверку в `udpateHook()`

