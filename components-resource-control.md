Арбитр ресурсов
======================

Описыватется реализация переключениия походок, которая включает два элемента: арбитр и клиентская подсистема задатчика. 
Обмен осуществляется при помощи портов и сообщений, описанных ранее в [переключении задатчиков](gait-switching).
Выбрана максимально асинхронная схема обмена, чтобы не блокирровать компонент задатчика.

Варианты реализации клиентской части:
1. Наследник `TaskContext`, от которого наследуются все компоненты-задатчики. (Статическое связывание). 
2. Компонент, куда пользовательский код загружается как плагин. 
    (Неудобно из-за отсутсвия полнного доступа к кода задатчика к компоненту, весь интерфейс задатчика окажется в пространстве имен сервиса).
3. Клиентская часть является сервисом. (Динамическое связывание, удобно для тестирования задатчика отдельно, но сложности с взаимодействием).

Далее рассматривается **клиентская часть-сервис**, остальные реализуются аналогично.
Для взаимодействие используется интегральный тип данных `ResourceList`:


Клиентская  часть: сервис `ResourseСlient`
-------------------------------------------

Внешний интерфейс (связь с арбитром):

Выходные порты:

1. `resource_request` (`ResourseRequest`) --- запросы ресурсов к арбитру.
1. `resource_requester_status` (`ResourseRequesterStatus`) --- изменение состояния компонента после перераспределения ресурсов или при деактивации.

Входные порты:

1. `resource_assigment` (`ResourseAssigment`) --- ресурсов по компонентам.

Внутренний интерфейс (связь с кодом задатчика):

1. Предоставляет: `bool requestResources(strings req [, ints pri1, ints pri2] )` --- изменить состав ресурсов, формирует запрос `ResourseRequest` и отправляет его арбитру. 
1. Предоставляет: `bool stopOperational()` --- уведомить арбитр о деактивации (посылает `ResourseRequesterStatus`)
1. Предоставляет: `bool isOperational()` 
1. Предоставляет: `bool hasResource(string res)`, `bool hasResources(strings  res)`
1.  Обработка сообщений арбитра.
     
     Предоставляет: `void step()` --- функция, которая должна переодически вызываться в `updateHook()`.
    
    ИЛИ

     Устанавливает callback `processResourceAssigment` на входной порт `resource_assigment`.

1. Средства уведомления пользовательского кода о изменении набора ресурсов.

    Требует (опционально): `bool hookResourceChange()` --- пользовательский callbcak, вызываемый при изменении состава ресурсов.
     Пользовательский код возвращает `true`, если компонент остается активен. 

     ИЛИ

     Метод: `void setResourceChangeHook(bool (*hookResourceChange)())

### Семантика исполнения

**`requestResources`** формирует запрос `ResourseRequest` и отправляет его арбитру.  Эта функция вызывается кодом пользователя  после проверки условий активации, сигнализирует о переходе в состояние ожидания активации (pending) из сотяний "активен", "не активен". В сотоянии "pending" игнорируется.

**`stopOperational`**  сигнализирует о деактивации. Вызывается пользовательским кодом для перехода в сотяние "не активен" (конец движения, отмена действия).

**`step`** должна вызываться в начале `updateHook()` для обработки сообщенией `ResourseAssigment`. 
Альтернативный вариант c `processResourceAssigment` предполагает использование EventPort с Callback функцией для вызова обработчика. 

Разбирает полученный список ресурсов и вызывает пользовательский `hookResourceChange`,  чтобы оперделить, согласен ли компонент со списком  выделенных ресурсов. Если `hookResourceChange` не реализован, то проверяает наличие последних запрошенных ресурсов 
и на основе этого меняет состояние задачика и посылает `ResourseRequesterStatus`. После этой операции компонент либо активен, либо нет.

### Детали реализации.

Вероятно, набор ресурсов проще всего хранить и передаваить в `vector<string>`.

Пример реализации задатчика:

    bool startHook() {
         vector<string> res = { "leg1", "tail" };
         req resource_client->requestResources(res);
    }
    bool hookResourceChange() {
        return resource_client->hasResource("leg1") && ... 
    }

    void updateHook() {
        resource_client->step();

        if (sync_port.read(sync_msg, false)) {
            if (resource_client->isOperational()) {
                ...
                ref_joints_port.write(ref_joints);
                if (resource_client->hasResource("tail") {
                    ...
                }
            }
            else { 
                 this->stop();  // stop component when it is nonoperational
            }
        }
    }

    stopHook() {
         resource_client->stopOperational();
     }

Серверная часть: компонент `resources_arbiter`
---------------------------------------------

Компонент регистрирует все задатчики, осуществляет прием извещений о изменении состава ресурсов/активных компонент, 
осуществляет перераспределние ресурсов.

Здесь описана модификация на основе операций.

### Входные порты

1. `resource_request` (`ResourseRequest`) --- запросы ресурсов к арбитру.
1. `resource_requester_status` (`ResourseRequesterStatus`) --- изменение состояния компонента после перераспределения ресурсов или при деактивации.

### Выходные порты

1. `resource_assigment` (`ResourseAssigment`) --- ресурсов по компонентам.

### Параметры

1. `strings list_orocos` --- список компонент-задатчиков OROCOS (опционально, чтобы предварительно выделить память под структуры и проверять корректность запросов).
1. `strings resources` - список ресурсов (опционально, для выделения памяти и проверки корректности запросов). 

### Операции

1. `assignAllResorsesTo(string component)` --- передать все ресурсы заданному компоненту или никому (`noone`)

### Семантика исполнения

Основной код --- обработка запросов --- содержится в **`updateHook`**. Семантика исполнения подробно расписана в [переключении задатчиков](gait-switching). Некорректный запрос приводит к ошибке.

### Детали реализации.

Удобно создать структуру для хранения данных о задатчиках: 
* сотояние (активен, ожидает активации, неактивен), 
* список выделенных ресурсов, 
* список желаемых, 
* приоритеты, 
* флаг того, что от задатчика ожидается ответ.

### Исключения и ошибки

Предупреждения:
1. Некорректное имя компонента в запросе.
1. Некорректное имя ресурса в запросе.

