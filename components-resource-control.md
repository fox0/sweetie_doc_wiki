Арбитр ресурсов
======================

Описыватется реализация переключениия походок, которая включает два элемента: арбитр и клиентская подсистема задатчика. 
Обмен осуществляется операциями, чтобы гаранторованно добится прихода ответа и детерминированного порядка исполнения кода арбитра.
Выбрана максимально асинхронная схема обмена, чтобы не блокирровать компонент задатчика.

Варианты реализации клиентской части:
1. Наследник `TaskContext`, от которого наследуются все компоненты-задатчики. (Статическое связывание). 
2. Компонент, куда пользовательский код загружается как плагин. 
    (Неудобно из-за отсутсвия полнного доступа к кода задатчика к компоненту, весь интерфейс задатчика окажется в пространстве имен сервиса).
3. Клиентская часть является сервисом. (Динамическое связывание, удобно для тестирования задатчика отдельно, но сложности с взаимодействием).

Дале рассматривается **колиентская часть-сервис**, остальные реализуются аналогично.
Для взаимодействие используется интегральный тип данных `ResourceList`:




Клиентская  часть: сервис `ResourseСlient`
-------------------------------------------

Внешний интерфейс (связь с арбитром):

1. Требует: `bool requestResourcesChange(ResourcesList req)` (всегда асинхронный вызов) --- используется для информирования арбитра о изменении статуса, возврат --- корректность запроса.
1. Предоставляет: `bool notifyResourcesChange(ResourcesList req)` (`OwnThread` (или `CkientThread` ?)) --- обработка уведомления о изменении состава ресурсов, предоставленного задатчику. Возврат: статус задатчика == активный.

**Замечание**. Если не планируется поддержка ROS, то сообщение можно развернуть в набор его полей (только необходимых). Указанная модифиация наиболее ROS-ready.

Внутренний интерфейс (связь с кодом задатчика):

1. Предоставляет: `bool startOperational(strings req [, ints pri1, ints pri2] )` --- изменить состав ресурсов, формирует запрос и асинхронно отправляет его арбитру. Возврат: невозможно запросить, предыдущий запрос не окончен.
1. Предоставляет: `bool stopOperational()` --- уведомить арбитр о деактивации. Возврат: невозможно запросить, предыдущий запрос не окончен.
1. Предоставляет: `bool isOperational()` 
1. Предоставляет: `bool hasResource(string res)` 
1. Предоставляет: `void step()` --- функция, которая должна переодически вызываться в `updateHook()`.
1. Требует (опционально): `bool hookResourceChange()` --- пользовательский callbcak, вызываемый при изменении состава ресурсов. 
    Пользовательский код возвращает `true`, если компонент остается активен. 

### Семантика исполнения

**startOperational** транслирует список ресурсов пользователя в асинхронный вызов `requestResourcesChange`. 
Эта функция вызывается кодом пользователя при активации, после проверки условий активации, сигнализирует о переходе в состояние ожидания подтверждения (pending).
Сбор результата происходит асинхронно в `step`, если требуется.

**stopOperational** транслирует в асинхронный вызов `requestResourcesChange`. Пользовательский код сигнализирует о деактивации.

**notifytResourceChange** обработка выделенного списка ресурсов. Фактически просто разбирает полученный список и вызывает пользовательский `hookResourceChange`, 
чтобы оперделить, согласен ли компонент со списком  выделенных ресурсов. Если `hookResourceChange` не реализован, то просто проверяает наличие последних запрошенных ресурсов 
и на основе этого меняет состояние задачика. После этой операции компонент либо активен, либо нет.

**step** нужна для реализации на сообщениях, здесь можно обработать результаты `requestResourcesChange`.

### Детали реализации.

Вызов `requestResourcesChange` может провалиться, по разным причинам. Не очень ясно, что происходит, если быстро посылается несколько оераций. 
Эту ситуацию, вероятно, надо обрабатывать в `step`. Вероятно, нужен способ уведомления пользовательского кода, либо повторять запрос. Зависит от частоты провалов. 

Вероятно, набор ресурсов проще всего хранить и передаваить в `vector<string>`.

Попытка ожидания на операции `requestResourcesChange` может привести к deadlock.

Пример реализации задатчика:

    bool hookResourceChange() {
        return resource_client->hasResource("leg1") && ... 
    }

    void updateHook() {
        resource_client->step();

        if (sync_port.read(sync_msg, false)) {
            if (isOperational()) {
                ...
                ref_joints_port.write(ref_joints);
                if (resource_client->hasResource("tail") {
                    ...
                }
            }
        }
    }

Серверная часть: компонент `resources_server`
---------------------------------------------

Компонент регистрирует все задатчики, осуществляет прием извещений о изменении состава ресурсов/активных компонент, 
осуществляет перераспределние ресурсов.

Здесь описана модификация на основе операций.

### Входные порты

Отсутствуют.

### Выходные порты

Отсутствуют.

### Параметры

1. `strings list_orocos` --- список компонент-задатчиков OROCOS.

<!-- 
1. `strings resources` - список ресурсов (для проверки корректности запросов). 
-->

### Операции

1. Предоставляет: `bool requestResourcesChange(ResourcesList req)` (`OwnThread`) --- основная операция перераспределния ресурсов.
1. Требует: `bool notifyResourcesChange(ResourcesList req)` --- извещение компонент о списке ресурсов.

**Замечание**. Если не планируется поддержка ROS, то сообщение можно развернуть в набор его полей (только необходимых). Указанная модифиация наиболее ROS-ready.

### Семантика исполнения

**Конфигурация**. Для всех компонент из списка задатчиков проверяет  наличие операции `notifyResourcesChange()`.
Если нет компонента или операции `releaseResosurces()`, то конфигурация считается не успешной. Иначе подключает к всем компонентам  свою операцию `requestResourcesChange()`.

**requestResourcesChange**. Арбитр хранит список принадлежности ресурсов, список активных компонент. 
При получении запроса в соответсвие с полученным запрсам осуществляется перерасперделение ресурсов (либо прямое вытеснение, либо приоритеты, [подробнее](gait-switching))
Активные компоненты извещаются через `notifyResourcesChange`, если какой-то деактивируется, то ресурсы снова перераспределяются.

### Детали реализации.

Переключение может длиться долго, т.к. требует ожидания исполнения операций на всех компонентах списка.

Некоторое ускорение можно добиться асинхронным вызовом операций (`send`). 
Ожидание исполнения операций необходимо, если хочется гарантировать синхронность переключений.

Могут возникнуть проблемы с реализацией процедуры конфигурации. 

### Исключения и ошибки

Ошибки:
1. Некорректный с набор компонент при конфигурации: нет компонента, нет операции.

