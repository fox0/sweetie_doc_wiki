Арбитр ресурсов
======================


Серверная часть: компонент `resources_control`
---------------------------------------------

Компонент регистрирует все задатчики, осуществляет прием запросов на ресурсы и формирование требований на освобождение ресурсов.

Здесь описана модификация на основе операций. Прототипы операций совместимы с сервисами ROS (спецтребование). 

### Входные порты

Отсутствуют.

### Выходные порты

Отсутствуют.

### Параметры

1. `strings list_orocos` --- список компонент-задатчиков OROCOS.
1. `strings list_ros` --- список компонент-задатчиков ROS.
1. `strings resources` --- список ресурсов (для проверки корректности запросов).

### Операции

1. Предоставляет: `bool requestResources(ResourceRequest req, bool success)` (`OwnTread`)
1. Требует: `bool releasetResources(ResourceRequest req, Empty)` --- для каждого зарегистрированного компонента.

### Семантика исполнения

**Конфигурация**. Для всех компонент из списка задатчиков проверяет  наличие операции `releaseResosurces()`.
Если нет компонента или операции `releaseResosurces()`, то конфигурация 
считается не успешной. Иначе подключает к всем компонентам  свою операцию `requestResources()`.

**Исполнение**. По вызову `requestResources` для всех компонент из списка задатчиков, кроме пославшего запрос, 
вызывает `releaseResosurces` с полученным списком ресурсов. Потенциально число запросов можно сократить, 
если следить за множеством активных компонент и извещать только их.

Запрос ресурсов неудачен, если имени запрашивающего компонента (`req.name`) или какого-то из ресурсов нет в списке. 

Компонент считается активным после `requestResources()` и пока `releaseResosurces()` не вернула `true`.

**Замечание**: Поведение значительно проще, если использовать сообщения. Список не требуется, достаточно просто сделать эхо.


### Детали реализации.

Переключение может длиться долго, т.к. требует ожидания исполнения операций на всех компонентах списка.

Некоторое ускорение можно добиться асинхронным вызовом операций (`send`). 
Ожидание исполнения операций необходимо, если хочется гарантировать синхронность переключений.
Результаты операций можно потом собрать в `updateHook()`.

Могут возникнуть проблемы с реализацией процедуры конфигурации. 

Передача задатчиком не своего имени приведет к deadlock (`OwnTread`).

### Исключения и ошибки

Ошибки:
1. Некорректный с набор компонент при конфигурации.


Клиентская часть: абстрактный класс `ResourceConsumer`
-----------------------------------------------------

Реализует общую часть интерфейса задатчиков.

### Входные порты

Отсутствуют.

### Выходные порты

Отсутствуют.

### Параметры

Отсутствуют.

### Операции

1. Требует: `bool requestResources(ResourceRequest req, bool success)` 
1. Предоставляет: `bool releaseResources(ResourceRequest req, Empty)`
1. `bool isOperational()` --- активен ли задатчик.

### Методы

1. `getResourceSet()`, `bool hasResource(const string& res)` --- проверка обладания ресурсом.
2. `bool requestExclusiveResources(const strings& resourses)` --- захватить набор ресурсов (пытается вызвать операцию requestResources()).
1. `bool setOperational(bool activate)` --- изменить состояние, очистить список ресурсов при деактивации.
3. `virtual bool notifyResourcesAcquire()` (реализуется в наследнике-задатчике) --- извещает задатчик о успешном захвате.
4. `virtual bool notifyResourcesRelease()` (реализуется в наследнике-задатчике) --- извещает задатчик о освобождении ресурсов.

### Семантика исполнения

**`requestExclusiveResources`**. Послать запрос, запомнить список ресурсов, вызвать `notifyResourcesAcquire()`. Если операция не готова --- неудача.

**`releaseResources`**. Если компонент не активен, то ничего не делать. Иначе проверить пересечение ресурсов компонента и полученного списка. Если пересекается, очистить список, вызвать `notifyResourcesRelease()`. 

**Исполнение**. Вызов кода задатчика в `updateHook`. Однако формирование задающего воздействия должно происходить, только если компонент активен.

Само решение о запуске/остановке/активации/деактивации принимает код задатчика, вызывая `setOperational()` в `notifyResources*` (или ином месте, если ресурсы, к примеру, компоненту не требуются).

### Детали реализации

Реализации по умолчанию:

    void notifyResourcesAcquire() {
         if (!isRunning()) start();
         setOperational(true);
    }
    void notifyResourcesRelease() {
         setOperational(false);
         stop();
    }

Типовой код задатчика:

    void updateHook() {
        if (sync_port.read(sync_msg, false)) {
            if (isOperational()) {
                ...
                ref_joints_port.write(ref_joints);
            }
        }
    }

Интерфейс несколько переусложнен, что связано с поддержкой альтернативных протоколов: на основе сообщений, запросы с приоритетами.

При реализации системы переключения на базе сообщений (портов) для обработки входящих сообщений компонент должен быть запущен на этапе посылки запроса.
Рекомендуемый механизм обработки сообщений callback-метод из `addEventPort`.

При реализации системы переключения на базе операций потенциально можно отождествить стояние "активен" и "запущен". 

Чтобы предотвратить выполнение клиентского кода в `updateHook()` в стоянии отличном от "активен", возможны два подхода:
1. Обязать задатчик размещать свой код в методе `abstract void updateHookOperational()`. В этом случае 
2. Метод `bool isOperational()` и обязать код задатчика делать проверку в `udpateHook()`. (См. код примера).

