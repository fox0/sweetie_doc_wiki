Обращение модели приводов `servo_inv_*`
=======================


Компонент рассчитывает задание для приводов с дискретным позиционным управлением 
по параметрам желаемой траектории (позиция, скорость) и необходимому моменту.

Компонент  `servo_inv_lead`
---------------------------

Рассчитывает целевую позицию привода исходя из предположение, что ПИД-регулятор привода обеспечивает точную отработку заданной позиции.
Формирует упреждение на заданное число циклов управления.

### Входные порты

1. `joints_fixed` (`JointState`, EventPort) --- желаемое состояние для приводов, порядок приводов не меняется.

1. `sync_step` (`int`) --- порт индикации начала нового цикла управления.

### Выходные порты

1. `goals` (`ServoGoal`) --- задания для приводов.

### Параметры

1. `period` (`float`) --- длительность цикла управления, секунды.

1. `lead` (`float`)  --- упреждение в секундах.

### Операции

Отсутсвуют.

### Семантика исполнения

Предполагается, что генератор траектории привода настроен в режиме прямоугольной скорости. (Нулевая длительность фазы ускорения по отношению длительности движения для приводов Herkulex).
По получению нового желаемого состояния, происходит вычисление команды для приводов по формуле:

    servo_goal_position = desired_position + (desired_position - previous_desired_position) * lead / period
    servo_gaol_duration = laed + period


### Исключения и ошибки

Предупреждения:
1. Изменение числа приводов.


Компонент  `servo_inv_param`
---------------------------

Использует статическую модель привода, аналогичную используемой в проекта NimbRo-OP. Модель учитывает изменения напряжения питания, силу трения, передаточные коэффициенты приводов.
При формировании команды для привода берется упреждение.

### Входные порты

1. `joints_accel_fixed` (`JointAccelState`, EventPort) --- желаемое состояние для приводов, порядок приводов не меняется.

1. `servo_model` (`ServoModel`) --- порт для обновления списка моделей приводов. Используется для передачи модели от модуля идентификации к компоненту. 
    Модель добавляется или заменяет соответвующую в списке моделей (параметр модуля).

2. `battery_state` (`sensor_msg::BatteryState`) --- состояние батареи, в частности напряжение питания приводов.

1. `sync_step` (`int`) --- порт индикации начала нового цикла управления. 

### Выходные порты

1. `goals` (`ServoGoal`) --- задания для приводов.

### Параметры

1. `period` (`float`) --- длительность цикла управления, секунды.

1. `lead` (`float`)  --- упреждение в секундах.

1. `default_servo_model` (`ServoModel`)  --- модель привода по умолчанию.

1. `servo_models` (`ServoModel[]`)  --- список моделей приводов. 

1. `battery_voltage` (`double`)  --- напряжение батареи по умолчанию.

1. `sign_dead_zone` (`double`)  --- мертвая зона операции взятия знака скорости для устроения оценки силы трения Кулона.

### Операции

Отсутствуют.

### Семантика исполнения

Предполагается, что генератор траектории привода настроен в режиме прямоугольной скорости. (Нулевая длительность фазы ускорения по отношению длительности движения для приводов Herkulex).

**Запуск** или **обработка первого сообщения**: проверяется корректен ли список моделей (нет дублирующихся, возможно, диапазоны параметров) 
и устанавливается соответствие с полученной позой и элементами списка. Для приводов с неизвестными моделями используется модель по умолчанию.

**Исполнение**. Получает задающее воздействие для каждого звена в виде четверки позиция, скорость, ускорение, развиваемый момент. Используя эти значения рассчитывает
команду для привода `goals` аналогично [Compliant Robot Behavior using Servo Actuator Models identified by Iterative Learning Control], 
перед посылкой команды берет упреждение по тому же алгоритму, что `servo_inv_lead`. Отличие состоит в том, что убран эффект Штрибека и используется полученное расчетное
значение ускорения. Точнее, модель привода имеет вид:

    Kp*(position_ref - position)*battery_voltage = alpha[0]*acceleration + alpha[1]*velocity + alpha[2]*sign(velocity) + alpha[3]*torque,
    servo_goal = position_ref*kgear.

Из первого уравнена рассчитывает `position_ref` --- задающее воздействие для П-регулятора привода, а потом она пересчитывается в команду для привода `servo_goal`.

**Сообщение `servo_model`**. Предназначено для обновления моделей, когда компонент запущен. Находит соответствующую модель с списке моделей и заменяет ее. 
Все действия исполняются после обработки `joints` и формирования `goals`.


* При необходимости переупорядочивается список моделей, чтобы он в соответствовал порядку сочленения в `JointState`. Установление соответствия между моделями 
* Если нужной модели нет в списке, то в соответствующую позицию добавляется модель по умолчанию.


### Детали реализации

Т.к. порт `joints` декларирован как `fixed`, то в процессе исполнения порядок звеньев не меняется, что можно использовать для выборки нужной модели.
Соответственно возможны разные способы установления связи между списком моделей и приводами. 
1. По имени. Создается `map<string,ServoModel>` или `map<string,ServoModel&>`, по которому находится соответствующая модель или номер ее в списке моделей. 
    Минусы: медленно, дополнительные структуры данных.
2. По позиции в списке моделей. При инициализации список моделей переупорядочивается с соответствие с порядком сочленений  в `JointState`. 
    Добавлются модели по умолчанию, если модель в списке отсутвует.
    Минусы: операция обновления модели в активном состонии требует поиска по именам сложности N.
3. По позиции в `JointState`. Создание отдельного от параметра `servo_models` упорядоченного списка моделей.
    Минусы: дополнительная структура данных, длительность выборки по имени.
4. Создание индекса. Гибрид 2 и 3. Создается индекс, переводящий позицию звена `JointState` в номер соответствующей модели в параметрах.
    Минусы: нельзя менять параметры в процессе работы, длительное создание индекса.
Рекомендуемый вариант --- 3, реализованин 4.

### Исключения и ошибки

Предупреждения:
1. Изменение числа приводов.
1. Отсутствие модели для привода, лишние модели.

