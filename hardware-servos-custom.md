Приводы хвоста и ушей, датчики касания, управляемые по протоколу Herkulex
======================================

Отдельный элементы исполнительной и сенсорной системы предлагается подключать к бортовому компьютеру по протоколу Herkulex используя шины управления приводами.

Примеры таких устройств:
* Приводы ушей и хвоста, выполненные на базе стандартах сервомашинок и контроллера (8-битны AVR или ARM Cortex-M). 
* Датчики касания копыт.
* Перспективная собственная прошивка для приводов.

**Достоинства** такого решения:
* Не требуется отдельных линий или шин управления (особенно актуально для ног).
* Использование существующего ПО управления приводами (актуально для приводов хвоста и ушей).

**Недостатки**:
* Малая пропускная способность шины (56700 бит/c)
* Накладные расходы протокола: заголовок любого сообщения --- 7 байт, режим ведущий-ведомый.
* Ориентированность текущего ПО на управление приводами. Что, например, затрудняет интеграцию опроса датчика касания, особенно многопозиционного, 
    т.к. текущее ПО ориентированного на обработку позиции и скорости. Для опроса иных величин требуется серьезная модификация.

Анализ аппаратное обеспечения
-----------------------------

Любое устройство представляет собой:
* понижающий преобразователь --- для питания МК и/или сервомашинки,
* микроконтроллер.

#### Возможные варианты реализации

**По типу используемого МК**
* 8-битные AVR (как в оригинальных приводах) --- не дает экономии по цене, серьезно ограничивает вычислительные ресурсы. Но если мы собираемся перешивать исходные приводы, то надо ориентироваться на него.
* 32-битные ARM Cortex-M (без плавающих точек) --- вероятно, лучший вариант для датчиков касания или управления сервомашинками.
* 32-битные ARM Cortex-M (с плавающими точками) --- необходим для случая, когда нужна серьезная математическая обработка (захотим сделать свой привод).

**По способу управления приводами** 
* аналоговые/цифровые сервомашинки управляемые по ШИМ --- простейший вариант. Требуется предусмотреть возможность отключения питания привода. 
* датчик позиции и двигатель, алгоритм управления реализуется МК --- реализация собственного сервопривода. 

**По числу эмулируемых устройств**
* одно устройство
* несколько устройств --- хорошо подходит для приводов ушей/хвоста, когда один МК управляет несколькими сервомашинками.

#### Предполагаемый облик системы

* В случае кроссплатформенной реализации протокола МК может быть выбран исходя из задачи. Наилучший кандидат --- ARM Cortex-M.
* Возможность эмуляции нескольких устройств на одном МК.
* Ранние версии не предполгают самостоятельного управления приводом.


Программное обеспечение
-----------------------

### Требования:

* Ведомое устройство, минимальные задержки обработки команд.

* Реализация следующих команд протокола Herkulex: 
    * `EEP_WRITE`
	* `EEP_READ`
	* `RAM_WRITE`
	* `RAM_READ`
	* `STATUS`
	* `I_JOG`
	* `RESET`
	Необходимость реализации команд `EEP` обусловлена необходимостью назначения ID, `RAM` команды необходимы для настройки (лимиты перемещения) или опроса сотояния (датчики),
	`I_JOG` нужна для управления движением, `STATUS` и `RESET` для инициализации привода.

	Вероятно, также стоит реализовать оставшиеся две команды: `ROLLBACK` и `S_JOG`.

* Кроссплатформенность базовой реализации протокола.

* Инкапсуляция реализации протокола относительно оставшейся части прошивки.

* Поддержка нескольких устройств одним МК.

* Корректная обработка неверных команд (контрольная сумма, неизвестный код команды, защита от записи, выход за пределы таблицы регистров).

* Детектирование события нехватки времени для обработки событий (?)



### Концепция реализации

Таблицы регистров реализуются как непрерывные области памяти в ROM (значения EEPROM умолчанию), EEPROM (настройки) и RAM (переменные значения). Адреса этих таблиц не фиксированы, 
для обеспечения поддержки нескольких устройств. Предлагается ввести структуру с информацией о устройстве (размеры таблиц, гараницы области только для чтения).
Для упрощения доступа вводятся переменные-константы со смещениями регистров, однако длину регистра программист должен определять самостоятельно (вводить массив длин регистров выглядит избыточным усложнением).

Кросспатформенность достигается использованием следующего интерфейса. 

Модель взаимодействия с остальной частью прошивки --- асинхронная, осуществляется путем чтения/записи регистрового файла.
Регистровый файлы имеет следующую организацию:
1. EEPROM регистры (хранятся в РППЗУ, область запрещения записи через протокол в начале файла).
2. RAM регистры (хранение в ОЗУ, область запрещения записи через протокол в конце файла).
При инициализации файл EEPROM регистров копируется в файл RAM. При этом пропускается часть первых EEPROM регистров.
Такая организация соответствует регистровому файлу приводов Herkulex.

Аппартно-независимая часть протокола **предоставляет**
* функцию инициализации/сброса.
* функцию-обработчиком получения очередного байта и конца пакета (пояснения смотрите ниже).
**требует** реализацию следующих аппартно-зависимых функций.
* функции операций записи в регистр и чтения в регистр (в RAM или EEPROM) --- для нужд пользовательской части кода.
* функции записи/непрерывного фрагмента регистрового файла --- для нужд реализации протокола.
* функции посылки массива байт или одного байта.

Операции чтения/записи регистрового файла должны быть атомарными. Здесь возможны разные модели:
1. Критические секции --- поддерживается AVR, ARM.
2. Неблокирующие атомарные операции --- поддерживается ARM.
3. Использование сочетания критических секций и приоритетов: пишущий/читающий регистры код протокола имеет всегда более низкий приоритет, чем прикладной код. 
    По этой причине защищать критическими секциями обращения к регистрам в прикладном коде не требуется. Нужна защита только для операций чтения/записи на уровне протокола.
Третий вариант менее универсален, чем второй. Но для порддержки совместимости с AVR при сохранении скорости доступа к регистрам предлагается использовать его.

Модель приоритетов. Здесь возникают определенные сложности, в частности, обусловленные отсутсвием развитой системы приоритетов на AVR.`
Предлагается выделить следующие группы (с ростом номера приоритет ниже):

1. обработчик получения байта (буфер приемника не пуст) --- реализуются протоколом, должен обеспечит быструю обработку полученного байта и помещение его в буффер пакета.
2. обработчики событий --- различные события МК, требующие быстрой обработки. Для рассматриваемых задач, скорее всего, не нужны, кроме, быть может, события нажатия кнопки датчика касания.
3. обработчик прерывания таймера --- операции, которые должны выполнятся периодически, напимер, формирование значения ШИМ для двигателя или опрашивая датчики и занося их показания в регистры. Это основной прикладной код.
4. обработчик завершения получения пакета (програмнное событие) --- реализуется протоколом, должен вызываться, когда получен корректный пакет (сигнализировать о этом может обработчик получения байта), здесь реализуется фомирование ответа и его посылка.

Обработчики событий и обработчик получения байта могут быть переставлены местами в зависисмости от приложения. Завершение получения пакета несет низший приоритет, т.к. включает в себя длительную операцию посылки ответного пакета. Она не должна нарушать работу прошивки (обработку событий и прерываний таймера) 

Разделение функций между обрабочиками байта и конца пакета может быть разным:
1. обработчик получения байта проверяет только корректность контрольных сумм и длину пакета, обработчик конца пакета выполняет команду команды, формирует ответ полылает его.
2. обработчик байта проверяет корректность пакета, исполняет команду и записывает ответ в буффер (все эти операции относительно быстрые), тогда единственная функция обработчика конца пакета --- посылка буфера ответа, сооветвенно она моежт быть реализована как функция записи в порт.
3. обработчик получения байта выполняет только операцию бцфферизации, обработчик пакет выделяет его в потоке байт, проверяет контрольные суммы, исполяет команды и посылает ответ. В этом случае его код исполняется непрерывно.
Первый вариант более логичен, но требует наличие двух буфферов получаемых данных. Также в нем проще реализется поддержка нескольких ID для одного устройства, т.к. обработчик байта не зависит от таблицы регистров.и типа устройства. Третий вариант --- это фактически упрщенный первый, т.к. позволяет использовать один циклический буффер вместо двух. Но здесь возникают проблемы с адресацие байт в циклиеском буффере, его невозможно использовт для формирования ответного пакета.

В всех случаях необходимо предусмотреть, чтобы обработка очередной команды не началась до завершения обработки предыдущей (переполнение циклического буфера).

Модель приоритетов можно упростить. Но тогда возможны следующие эффекты (в зависимости от характера упрощения):
* во время посылки пакета не происходит обработки событий, не производятся периодические действия.
* время от времени происходит переполнение буфера UART, т.к. его прерывание не имеет достаточного приоритета.

Деление на модули 
* `herkulex_protocol` --- аппартно-независимая часть протокола, включая декларацию типов данных.
* `herkulex_protocol_<arch>` --- аппартно-зависимая часть протокола (обращение к таблицам регистров) --- зависит от архитектуры устройства.
* `herkulex_registers` --- таблицы регистров и их праметры --- зависит от устройства.
* `main`, `appl` --- обработчики прерываний, процедура посылки байта, инициализация, прикладной код --- зависит от устройства.

### Детали реализации

Предлагаемая реализация, основанна на следующих архитектурных решениях:
* три приоритета: обработчики прерываний (получение байта, события прикладного кода), периодическая процедура прикладного кода, код протокола.
* обработчик события получения байта (прерывание буфер приемника не пуст) выполняет буферизацию, подсчет контрольных сумм и определние конца пакета (вылавливает все пакеты).
* обработчтк пакета исполняет полученную команду хрвнящегося в виде пакета в буффере для данного регистрового файла.
* используется метод двойной буфферизации для обмена между обработчиками: пока байты следующего пакета накапливаются в одном буффере, обработчик пакета работает с другим. Потом эти буферы меняются местами.
* обеспечение атомарности операция чтения записи выполняется за счет приоритезации приклодного кода над кодом протокола и критических секций на уровне протокола.

#### Механизм двойной буферизации

Переменные (члены-данные): 

    static char * buffer[2*FRAME_BUFFER_SIZE];
    char * receive_buffer = buffer;
    char * frame_buffer = buffer + FRAME_BUFFER_SIZE;
    bool frame_buffer_full_flag; // set if receive_buffer contains full frame and must be swapped with frame_buffer. 

Может быть реализован как объект С++ или отдельный модуль на C. Однако предлагается реализовать его напрямую в коде протокола.
`frame_buffer_full_flag` используется для сигнализации о необходимости начать обрабатывать новый кадр. Если при регистраци  начала следующего пакета этот флаг поднят, то это ошибочная ситуация, 
очередной фрейм будет потерян, т.к. не завершена обработка предыдущего.

#### Регистровые файлы

**Общее описание устройства** тип данных в аппаратно зависимой части памяти 

	// herkulex_protocol_<arch>.h
	struct herkulex_device_t {
	   <memory_declarator> char * eep_file_addr; // must pount to EEPROM memory zone
	   uint eep_file_size; // size in bytes
	   uint eep_file_rw_zone_offset; // from which position in bytes registers are writeble by `EEP_WRITE` protocol command

	   char * eep_file_default_values_addr; // default register values for `ROLBACK` command.

	   char * ram_file_addr;
	   uint ram_file_size;
	   uint ram_file_ro_zone_offset; // from which position registers are read-only for `RAW_WRITE` protocol command.

	   uint eep_to_ram_copy_zone_offset; // offset of the zone of EEP file, which should be copied to RAM file during initialization.
	};

Для декларации регистровых файлов можно использовать разные подходы. 

Константы смещений и файлы регистров (можно убрать `define`, но тогда декларации не будут кросплатформены):

	// herkulex_protocol_<arch>.h
	#define EEP_REGISTERS(device) enum eep_offsets_##device = 
	#define EEP_FILE(device, size) <memory_declarator> char eep_file_##device[size]
	#define EEP_FILE_DEFAULT(device) <memory_declarator> const char rom_file_##device[size]

	#define RAM_REGISTERS(device) enum ram_offsets_##device = 
	#define RAM_FILE(device, size) char ram_file_##device[size]

	#define HERKULEX_DEVICE(DEVICE, EEP_FILE_RW_OFFSET, RAM_FILE_RO_OFFSET, EEP_TO_RAM_COPY_OFFSET) const struct herkulex_device_t DEVICE = { .eep_file_addr = &eep_file_##DEVICE, .eep_file_size = sizeof(eep_file_##device), .eep_file_rw_zone_offset = EEP_FILE_RW_OFFSET, ... }

	// herkulex_registers.h
	EPP_REGISTERS(servo1) {
	   EEP_MODEL1 = 0,
	   EEP_MODEL2 = 1,
	   EEP_ID = 6,
	   EEP_ACK_POLICY = 7, 
	   ..
	   EEP_FILE_SIZE = 54
	}; // константы смещений регистров

	extern struct herkulex_device_t servo1;

	// herkulex_registers.c
	EPP_FILE(servo1, EEP_FILE_SIZE) = { // сама область памяти
	   MODEL1, MODEL2 // значения по умолчанию
	};
	EPP_FILE_DEFAULT(servo1) = { 
	   значеня регистров подряд, включая пропуски)ю
	}

	RAM_REGISTERS(servo1) {


	}
	RAM_FILE(servo1);

	HERKULEX_DEVICE(servo1, 4, 54, 6)

Адреса регистров разрешаются на этапе компиляции.

Второй вариант состоит в использовании структур. Имя регисира --- имя поля структуры, содержащей информацию о нем: смещение, длину, атрибут чтения-записи, значение по умолчанию.
Тогда обращение к регистру выгдядит как выборка смещения (при помощи define) и последующее обращение к самой области регистра. ОДнако все равно имена регистров должны 
декларироваться в .h файле, а значения смещений и т.п. --- в .c.

#### Структура пакета


**Описание структуры пакета** (для случая, кода первые два байта загововка не хрянятся), вероятно, можно не использовать

// herkulex_protocol.c
enum frame_offsets_t { 
    PACKAGE_SIZE = 0;
	PACKAGE_ID = 1;
	PACKAGE_CMD = 2;
	PACKAGE_CHECKSUM1 = 3;
	PACKAGE_CHECKSUM2 = 4;
	PACKAGE_DATA = 5;
}

#### Обращение к регистровым файлам

**Пользовательский интерфейс**. 
Возврат false в случае неуспеха (недопустимая операция, выход за диапазон и т.п.). Другой вариант --- встроенный assert. 
Приведены  беззнаковые версии функций не приведены.

	// herkulex_protocol_<arch>.h
	bool eep_read_i8(herkulex_device_t * device, uint offset, uint8 * value);
	bool eep_write_i8(herkulex_device_t * device, uint offset, uint8 value);
	bool eep_read_i16(herkulex_device_t * device, uint offset, uint16 * value);
	bool eep_write_i16(herkulex_device_t * device, uint offset, uint16 value);

	bool inline static ram_read_i8(herkulex_device_t * device, uint offset, int8 * value);
	bool inline static ram_write_i8(herkulex_device_t * device, uint offset, int8 value);
	bool inline static ram_read_i16(herkulex_device_t * device, uint offset, int16 * value);
	bool inline static ram_write_i16(herkulex_device_t * device, uint offset, int16 value);

#define ram_register_i8(device, offset) ((uint8_t *) device.ram_file_addr + offset)

**Интерфейс протокола с защитой памяти**
Возврат false в случае неуспеха (недопустимая операция, выход за диапазон и т.п.).
должна обеспечиваться атомарность (критическая секция)

	// herkulex_protocol_<arch>.h
	bool eep_read(herkulex_device_t * device, uint offset, uint size, uint8 * dst);
	bool eep_write(herkulex_device_t * device, uint offset, uint size,  uint8 * src);

	bool ram_read(herkulex_device_t * device, uint offset, uint size, uint8 * dst);
	bool ram_write(herkulex_device_t * device, uint offset, uint size,  uint8 * src);


#### Интерфейс протокола 


* `void herkulex_protocol_init(const herkulex_device_t * dev)`
    инициализация памяти для устройчтва `dev`: копирует EEP регистры в RAM, остальные инициализирует нулями.
* `	void herkulex_protocol_new_byte(char c)` --- обработчик получения байта, высокий приоритет.
	Реализуется в виде гибридного конечного автомата. Проверяет корректность контрольных сумм, устанавливает `frame_buffer_full_flag` и меняет местами буферы приема и кадра по завершению получения пакета. 
	Детектирует переполнение (при попытке обмена буферов `frame_buffer_full_flag` установлен.
* `	void herkulex_protocol_new_byte_corrupted()` --- информировать о потере байта или искаженном байте.
	Сбрасывает конечный автомат обработчика байта.
* `    void herkulex_protocol_spin(const herkulex_device_t * devs, uint ndev)` --- основной обработчик протокола, низкий приоритет.
	Проверяет frame_buffer_full_flag, если поднят то пытается обработать полученный кадр.
	В процессе проверяет ID, команду, проводит ее выполнение формаирует ответ, посылает его используя `herkulex_protocol_write()`.
	В конце обработки снимает флаг `frame_buffer_full_flag`.
    
	`devs` --- указатель на структуры с описанием устройств, `ndevs` --- их колическтво. 
* `extern bool herkulex_protocol_write(char * buffer, uint size)` аппаратно-зависимая функция отправки массива байт.
	Реализуется вне кода протокола. Может быть блокирующей или нет.


Наиболее сложно реализуется `herkulex_protocol_spin()`:

	void herkulex_protocol_spin(herkulex_device_t * devs, uint ndevs) {
	  if (frame_buffer_full_flag) {
		for(k = 0; k < ndevs, k++) herkulex_protocol_frame(dev + k);
	  }
	  frame_buffer_full_flag = false;
	}

	void herkulex_protocol_frame(herkulex_device_t * dev) {
	  uint id;
	  eep_read(dev, EEP_ID, id):
	  if (frame_buffer[FRAME_ID] != id) return;

	  herkulex_cmd_t cmd = frame_buffer[FRAME_CMD];
	  switch (cmd) {
		 case EEP_READ:
			 eep_read_cmd(dev);
			 break;

		 ...
		 default:
			 error();
	  }

	  frame_buffer_full_flag = false;
	}

	void eep_read_cmd(herkulex_device_t * dev) {
		if (frame_buffer[FRAME_LENGTH] != ...) error();
		uint offset = frame_buffer[FRAME_DATE + 0];
		uint len = frame_buffer[FRAME_DATE + 1];
		bool succes = eep_read(dev, , , frame_buffer + FRAME_DATA); // use recv buffer as send buffer.
		frame_buffer[FRAME_LENGTH] = ...
		frame_buffer[FRAME_CMD] = ...
		frame_buffer[..] = ram_register_i8(dev, RAM_STATE);
		calculate_checksums();
		herkulex_protocol_write(frame_buffer, ...);
	}
	

#### Интеграция с кодом устройства

    #include <herkulex_protocol.h>
    #include <herkulex_registers.h>
    
    // реализация операции записи в порт
    bool herkulex_protocol_write(char * buffer, uint size) {
      for(i = 0; i < size; i++) {
         wait_for(TX_BUFFER_EMPTY)
    	 TX_BUFFER = buffer[i];
      }
      i++;
    }
    
    //обработчик прерывания приемника
    void rx_buffer_full_isr() {
      if(RX_FRAME_ERROR) herkulex_protocol_new_byte_corrupted();
      else herkulex_protocol_new_byte(RX_RECEVE_BUFFER);
    }
     
    //обработчик прерывания таймера (прикладной код)
    void control_cycle() {
       ENABLE_IRQS();
    
       uint16_t pwm;
       ram_read_i16(servo1, RAM_PWM, &pwm);
       PWM_REG = pwm;
    
    }
    
    // инициальная прикладного кода
    void init(uint baudrate) {
       // TIMER
       // PWM
       // UART
    }
    
    void main() {
      uint baudrate;
      herkulex_init(servo1);
      eep_read(servo1, EEP_BAUDRATE, &baudrate);
      init(baudrate);
    
      for(;;) {
        herkulex_protocol_spin(servo, 1);
      }
    }


