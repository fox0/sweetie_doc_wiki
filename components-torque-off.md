Задатчик `TroqueMainSwitch`
----------------------------------------------------------------

Отключает все приводы, управляемые через подсистему `herkulex`.
Моджет быть использован в случае падения или для того, чтобы выставить позу робота вручную.

### Входные порты


1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.

1. `in_joints_sorted` (`JointState`) --- состояние робота в угловой СК (реальное по датчикам), сообщение отсортировано по кинематическим цепочкам.


### Выходные порты

1. `out_joints_ref` (`JointState`) --- активный задатчик выдет на этот порт текущую полную позу робота по датчикам (из `in_joints_sorted`).

1. `ref_support` (`SupportState`) --- ожидаемое распределение веса, неопреленное занчение.

### Параметры

1. `herkulex_arrays`, `herkulex_scheds` (`strings`) --- списоки интрерфейсных компонентов приводов.
1. `speed_zeroing` (`bool`) --- обнулять скорость в публикуемой позе.


### Операции

1. Предоставляет: `bool setOperational(bool)` --- активация и деактивация задатчика. 
    * Если аргумент `true`, активирует компонент. В отличие от вызова `start`, который всегда возвраает `true`,
          эта опреация возвращает информацию о успехе/неуспехе. В случае неуспеха компонент все равно активируется, 
          но может продолжить попытки отключить приводы потом.
    * Если аргумент `false`, деактивирует компонент. Поведение экввалентно поведению `stop`. 
    

ROS-совместимые:
1. Предоставляет: `rosSetOperational` (`std_srv::SetBool`/`sweetie_bot_resource_control_msg::SetOperational`) --- управление компонентом из ROS. 

### Сервисы 

2. Требует: сервис `robot_model`.

### Семантика исполнения

**Активация**: запрашивает ресурсы и не дожидасяь подтверждения отключает приводы. 
    Если отключение не удалось, в активном сотоянии попытки отключить приводы продолжаются.

**Деактивация**: включает приводы, делает несколько попыток в случае неуспеха.

**Исполнение**: копирует в `out_joints_ref` позу из `in_joints_sorted`


### Детали реализации

Последовательность включения/отключения (для ускрения процесса):
1. Деактивировать планировщики и запомнить их состояния. 
2. Вызвать `Herkulex:Array::setAllServosTorqueFree` 
3. Активировать планировщики, которые были активны.

### Ошибки и исключения

Ошибки:
1. Не могу подключиться к `HerkulexArray`/`HerkulexSched`.

