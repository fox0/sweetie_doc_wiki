Задатчик `FollowJointState`
----------------------------------------------------------------

Задатчик получает `geometry_msg::PoseStamped` от высшего уровня и отслеживает ее основанием робота, сохраняя постоянным набор опорных ног.
Основной вариант использования --- управление роботом при помощи [`pose_marker`](ros-pose-marker). Не учитывает пересечения, контакты, для слежения используется ПД регулятор.
Содержит код, следящий за исполнением условий статического равновесия (нарушающие его движения игнорируются),

Данный компонент является наследником наследником [`SimpleControllerBase`](components-gait), т.е. может быть активирован 
действие `SetOperational`, операцией `rosSetOperational` и операциями `start/stop()`. В качестве выделенных ресурсов может 
произвольный набор конечностей.

### Входные порты

1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.

1. `in_limbs_fixed` (`RigidBodyState`) --- состояние робота в декартовой системе (положение конечностей относительно основания), порядок не должен меняться.

1. `in_base` (`RigidBodyState`) --- положение основания относительно неподвижной СК.

1. `in_balance` (`BalanceState``) --- информация о равновесии (формируется модулем динамики).

1. `in_pose_ref` (`PoseStamped`) --- желаемое положение конечности относительно неподвижной СК.

### Выходные порты

1. `out_base_ref` (`RigidBodyState`) --- выход задатчика --- положение основания относительно неподвижной СК (для переопределни обометрии).

1. `out_limbs_ref` (`RigidBodyState`) --- выход задатчика --- положение конечности в декартовой СК относительно основания, передается модулю обратной кинематики.

1. `out_supports` (`SupportState`) --- информация о контактах. Все управляемые цепочки предполагаются находящимися в состоянии контакта.

### Параметры

1. `support_legs` (`strings`) --- набор конечностей, управляемых компонентом по умолчанию (наследуется от `SimpleControllerBase`).

2. `pose_feedback` (`bool`) --- если это значение false, то порты `in_base` и `in_limbs_fixed` используются стлько один раз 
    при старте компонента. В дальнешем для проведния расчетов используется их сохраненные значения (anchor). В этом режиме ограниченяи 
	кинематики могут быть учтены только при использовании операции `poseToJointStatePublish` для вызова кинематики.

3. `activation_delay` (`int`) --- при измении списка опор оценка положения основания робота может мгновеннр изменится, т.к. одометрия пересчитывает его с учетом списка контактов. 
    При активации компонент ждет `activation_delay` циклов управления после публикации `SupportState`, что позволяет ему получить уже исправленную обометрией позу,
	что важно, если `pose_feedback` установлено в `false`.

4. `check_balance` (`bool`) --- проверять упрощенные условия статического равновесия. Если входная поза их нарушает --- игнорировать ее.

5. `keep_balance` (`bool`) --- при детектировании нарушения условий равновесия пытается принять устойчивую позу.

### Операции

1. Требует: `bool poseToJointStatePublish(const RigidBodyState& pose)` --- синхронный вызов обратной кинематики. Для того 

ROS-совместимые:
1. Предоставляет: `rosSetOperational` (`std_srv::SetBool`/`sweetie_bot_resource_control_msg::SetOperational`) --- управление компонентом из ROS (наследуется от `SimpleControllerBase`)

### Сервисы 

2. Требует: сервис `robot_model`.
2. Требует: сервис `FilterRigidBodyState` --- используется для построения траектории для плавного изменения позы.

### Семантика исполнения

**Запуск**: сохранить текущее положение ног в неподвижной СК.

**Цикл управления**:
1. Получить 
    * желаемую позу основания 
	* текущую позу основания (в случае `pose_feedback == false` использует расчетную --- новая поза основания, полученную на предыдущем цикле).
	* текущую позу конечностей (в случае `pose_feedback == false` использует расчетные --- новые позы конечностей, полученную на предыдущем цикле).
2. Проверить условия равновесия для желаемой позы. Если не выполнены --- игнорировать желаемую позу. Проверить условия равновесия для робота.
2. Применить фильтр, чтобы получить новую позу основания.
3. Расчет новых поз ног:
    * Если `pose_feedback == false`, то рассчитать новые позы ног относительно новой позы основания, используя новую позу основания в неподвижной СК и сохраненные позы ног в неподвижной СК.
    * Если `pose_feedback == true`, рассчитать смещение между новой позой и текущей, по ним вычислить новые позы ног относительно новой позы основания.
4. Новые позы ног относительно новой позы основания передатся обратной кинематике.

Все ноги, управляемые компонентом считаются опорными с контактами по умолчанию.

Выходной порт `out_base_ref` можно использовать для перезадания результатов расчета обратной кинематики.

Синхронный вызов `poseToJointStatePublish` позволяет корректно обрабатывать кинематические ограничений.

### Детали реализации

В режиме `pose_feedback == false` пока не истек `activation_delay` обновлвять сохраненную позу.

Проверка равновесия сильно упощена: предполагается, что вся масса сосредоточена в основании, на основе этого расчитывается смещение центра масс при переходе в новую позу и
проверяется, не вышел ли он за пределы опоры.

Если включен режим `keep_balance` то при нарушении условия равновесия желаемая поза принудительно устанавливается в центр опорного многоугольника.

Если задача обратной кинематики для ног не имеет решения, то принудительно обновляются сохраненные позы ног, текущая поза основания.

### Ошибки и исключения

Предупреждения:
1. Получение некорректных сообщений.
1. Изменение структуры сообщения `in_limbs`.
