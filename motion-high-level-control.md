Высокоуровневый интерфейс системы управления
============================================

Данный документ содержит базовые идеи интерфейса между высокоуровневыми компонентами и системой управления робота.
В настоящий момент он не претендует на полноценное описание интерфейса или концепции его построения.
	
		
Тезисы
------

1. Для описания движений на низком уровне используются математизированные представления; траектория в угловой или абсолютной СК, 
    положение твердого тела в пространстве, точка в 3-х мерном пространсте. Большинство из них сложны для воспринимаются человеком.

2. Систем имитирующих ИИ (чатботы, недетерминированные конечные автоматы, системы на основе графов) работают с текстовым описанием действия 
    (педикаты? текстовые идентификаторы? как оно формализуется?)
    (взять кружку, подойти к человеку)  или состояния (вижу кружку, вижу человека, робот опрокинулся). Состояния могут относится к роботу и ко внешеней среде.

3. При управлении роботом на "средне" уровне полезно промежуточное представление команд, в виде текста и некоторого набора параметров (переместиться в точку с координатами,
    повернуть голову в направлении заданной точки).

4. Опыт задания движений и анимаций показывает, что одно высокоуровневое действие включает несколько низкоуровневых команд. Например, приветствие подразумевает
    * поворот головы на собеседника,
    * перевод глаз на собеседника, переключение анимации глаз в со отвевающее состояние,
    * протягивание передней ноги в сторону собеседника,
    * проигрывание фразы приветствия.
   При этом может потребоваться задание неких параметров, таких как положение собеседника в примере, его свойства (знаком, не знаком и т.п.).

5. Разложение высокоуровневого действия на низкоуровневые может быть разным по сложности описания:
   * сложное действие --- композиция нескольких простых,
   * сложное действие --- последовательность (конечный автомат) из простых.
   * разложение сложного действия в простые не просчитано заранее, эту задача решается на основе некого набора правил и представлений о мире.

6. В текущий момент в качестве основы высшего уровня управления рассматриваются:
    * [FlexBE](http://philserver.bplaced.net/fbe/) --- детерминированный конечный автомат с возможностью внешних параметров и событий. 
        Имеет удобный интерфейс для управления оператором. Основной элемент --- состояния-поведения, представляющеи собой модули написанные на python,
        выполняющие некоторое действие. 
    * Чатбот. Вход и выход чатбота --- текст и метки состояния робота и внешней среды. Трансляция показаний сенсорный системы во входные метки и преобразование 
        выходных меток в действия будет выполнятся отдельными модулями.


Идеи
----

1. Описание поведения робота следует по возможности осуществлять на как можно более высоком уровне. Для преобразования высокоуровневой команды в 
    низкоуровневые требуется специальный компонент или компоненты.

2. При использовании FlexBe такую роль исполнения высокоуровневых действий можно возложить на модули-поведения (тривиальное разложение действия) или подавтоматы. 
    Однако такое решение имеет ряд недостатков:
    * неудобство задания сложных параметров, громозкость описания низкоуровневых действия,
    * сложности реализации параллельных процессов и асинхронной реакции на события (например, команда "стой" для прекращения текущего действия),
    * плохая масштабируемость в смысле организации альтернативных цепочек действий (выбор одного действия из 10).
    Фактически это означает, что поведения FlexBe должны быть как можно более высокоуровневыми модулями. С меньшим числом парметров и ориентированными на конкретного робота.

3. *Чатбот может быть встроен в автомат, как поведение FlexBe*. Выходные метки активируют вложенные конечный автоматы, который выполняют соответствующие действие. 
    Входные метки формируется состоянием flexbe, классифицирующим состояние среды и робота.

    Сложность состоит в реализации возможности асинхронного принятия решения и прерывания текущего действия. FlexBe позволяет это сделать, но решение не идеально.
    В частности, в конечных автоматах-описаниях высокоуровневых действий сложно (если не невозможно) будет описать ветвь действий при прекращении текущего.

    Второй вариант состоит в *управлении автоматоми FlexBe через API `behavior_engine`*. 
    Тогда по метке, получаемой от чатбота, прерывается исполнение текущего автомата и активируется другой. При этом выбирать автомат по имени, 
    что очень удобно для масштабировании, передавать ему параметры. Также технически несложно организовать внуьри автомата критические секции и точки прерывания.
    Однако вопрос требует дальнейшего изучения. В этом случае действие не обязано быть автоматом FlexBe. Можно использовать такое же xml описание, как для 
    анимации глаз. 

4. Не ясно, как представлять модель состояния среды. 
     * Набор логических утверждений. ("свити_опрокинулась", "вижу_человека", "громкий_звук"). Утверждения снабжаются метаинформацией (например, положение человека). 
     * Педикаты. ("вижу(A) & человек(A)"). Существенно более сложное представление, позволяет работать с несколькими объектами. Объекты также снабжаются метаинформацией.
     Вероятно, разумно выработать некое промежуточное представление в зависимости от типа метаинформации и возможных действий объекта. 
     Например: "свити_опрокинулась() & свити_ждет_помощи() & вижу_объект(мяч) & вижу_человек(mutronics)"

5. Хранение описаний высокоуровневых действий:
    * xml-описание нескольких низкоуровневых действий (как у глаз) --- подходит для описания жестких программ, сложно передавать параметры, 
         легко написать исполняющий его автомат или поведение FlexBe
    * *поведение FlexBe* --- может принимать параметры, легко интегрируется в автоматы,
    * *автомат FlexBe* --- может принимать параметры, легко интегрируется в автоматы.

6. Типы действий по времени исполнения: 
     1. нахождение в некотором состоянии (сидеть, стоять, танцевать): длится неограниченно долго, сотояние может быть нарушено.
     2. выполнение конечного по времени действия (сесть, встать, покрутиться на месте): длится конечное время, может быть успешным или нет.
     3. перейти в заданное состояние и находиться (сесть и сидеть, встать и стоять): может быть успешным или нет, в случае успеха длится неограниченно долго, пока сотояние не нарушено.

     Не ясно, следует ли выделять третий тип. Однако низкоуровневый примитив "перейти в заданную позу и оставаться в ней" хрошо ложится именно на эту группу.

7. Необходимо сформировать список низкоуровневых действий на которые разлагаются высокоуровневые. Большинство из них реализуются советующими задатчиками.

В описанной концепции имеет место три уровня:
1. Низкий уровень: задатчики движений OROCOS.
1. Средний уровень: поведения и автоматы FlexBe.
1. Высокий уровень: подсистема принятия решения (чат-бот).

Список низкоуровневых действий
------------------------------

Большинство низкоуровневых действий исполняются непосредственно задатчиками движений.

0. Все сочленения (включая фиктивные):
    * Поместить в заданную позу в угловой СК (без учета самопересечение и позной устойчивости). (`FollowJointState`)
    * Повторить записанное движение. (`AnimationJointTrajectory`)
1. Голова
    * Смотреть на заданный объект/в заданном направлении. Слежение за объектом/направлением. 
    * Позиционировать рот/нос в заданную точку. Слежение за заданной точкой положения нос/рта.
    * Захват объекта ртом?
3. Глаза
    * Смотреть на заданный объект/в заданном направлении. Слежение за объектом/направлением.
    * Переключение эмоционального состояния, проигрывание анимаций.
4. Одна нога
    * Поместить копыто в заданную позу. Слежение за заданной позой. (`AnimationJointTrajectory`+`move_group` или ???)
    * Силовое взаимодействие с объектом? (Надавить на заданную точку).
5. Платформа, ноги и голова
    * Поменять положение платформы при сохранении положения опорных ног.
    * Переместить платформу в заданную точку (ходьба).
    * Двигаться в заданной скоростью (ходьба, рысь).
    * Принять известную позу (стоит, сидит и т.п.)
