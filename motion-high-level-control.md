Высокоуровневый интерфейс системы управления
============================================

Данный документ содержит базовые идеи интерфейса между высокоуровневыми компонентами и системой управления робота.
В настоящий момент он не претендует на полноценное описание интерфейса или концепции его построения.
	
		
Тезисы и проблемы
-----------------

1. Для описания движений на низком уровне используются математизированные представления; траектория в угловой или абсолютной СК, 
    положение твердого тела в пространстве, точка в 3-х мерном пространсте. Большинство из них сложны для воспринимаются человеком.

2. Систем имитирующих ИИ (чатботы, недетерминированные конечные автоматы, системы на основе графов) работают с текстовым описанием действия 
    (педикаты? текстовые идентификаторы? как оно формализуется?)
    (взять кружку, подойти к человеку)  или состояния (вижу кружку, вижу человека, робот опрокинулся). Состояния могут относится к роботу и ко внешеней среде.

3. При управлении роботом на "средне" уровне полезно промежуточное представление команд, в виде текста и некоторого набора параметров (переместиться в точку с координатами,
    повернуть голову в направлении заданной точки).

4. Опыт задания движений и анимаций показывает, что одно высокоуровневое действие включает несколько низкоуровневых команд. Например, приветствие подразумевает
    * поворот головы на собеседника,
    * перевод глаз на собеседника, переключение анимации глаз в со отвевающее состояние,
    * протягивание передней ноги в сторону собеседника,
    * проигрывание фразы приветствия.
   При этом может потребоваться задание неких параметров, таких как положение собеседника в примере, его свойства (знаком, не знаком и т.п.).

5. Разложение высокоуровневого действия на низкоуровневые может быть разным по сложности описания:
   * сложное действие --- композиция нескольких простых,
   * сложное действие --- последовательность (конечный автомат) из простых.
   * разложение сложного действия в простые не просчитано заранее, эту задача решается на основе некого набора правил и представлений о мире.
   Возможность совмещения нескольких простых действий --- необходимое требование поведению.

6. В текущий момент в качестве основы высшего уровня управления рассматриваются:

    * [FlexBE](http://philserver.bplaced.net/fbe/) --- детерминированный конечный автомат с возможностью внешних параметров и событий. 
        Имеет удобный интерфейс для управления оператором. Основной элемент --- **flexbe-состояние** (flexbe state), представляющеи собой модули написанные на python,
        выполняющие некоторое действие. Сотояние может иметь параметры, при активации способно получать аргументы от предыдущего сотония. 
        Из сотояний строятся конечные автоматы --- **flexbe-поведения** (flexbe behavior)

    * Чатбот. Вход и выход чатбота --- текст и метки состояния робота и внешней среды. Трансляция показаний сенсорный системы во входные метки и преобразование 
        выходных меток в действия будет выполнятся отдельными модулями.

7. Требуется уметь переключать движения без стыкующих стадий, должна быть возможность прервать текущее действие. 

8. Для непрерывного управления движением требуется непрерывно передавать информацию от датчиков к задатчику. (Слежение головой и глазами за человеком, копирование движения).


Идеи
----

Описание поведения робота следует по возможности осуществлять на как можно более высоком уровне. Для преобразования высокоуровневой команды в низкоуровневые требуется специальный компонент или компоненты.
Этот компонент должен обеспечивать интеграцию множества отдельных возможностей в заданное *поведениен*. При этом поведения могут сильно различаться, должна быть предусмотрена возможность выбора поведения по имени.
Здесь и далее *поведение* и *высокоуровневое действие* используются как синонимы.

В описанной концепции имеет место три уровня:
1. Низкий уровень: задатчики движений OROCOS.
1. Средний уровень: поведения  FlexBe.
1. Высокий уровень: подсистема принятия решения (чат-бот).

### Использование FlexBe

Роль исполнения высокоуровневых действий можно возложить на flexbe-состояния (тривиальное разложение действия) или flexbe-поведения (представление действия в виде конечного автомата из нескольких состояний). 
В первом случае используется python, а во втором --- графический редактор FlexBe.

Однако такое решение имеет ряд недостатков:
- неудобство задания сложных параметров, громозкость описания низкоуровневых действия средствами FlexBe,
- сложности реализации параллельных процессов и асинхронной реакции на события (например, команда "стой" для прекращения текущего действия),
- плохая масштабируемость в смысле организации альтернативных цепочек действий (выбор одного действия из 10 в FlexBe выглядит очень громозко),

Это означает, что 
- Состояния FlexBe должны быть как можно более высокоуровневыми модулями. Они должны обладать небольшим числом параметров и быть ориентированными на конкретного робота.
- Для обеспечения асинхронной реакции на события (прерывание действий, переключение поведения по событию) FlexBe должен работать под управлением супервизора, реализующего эти функции.

Для обеспечения "безшовных" сопряжений движений целесообразно не прерывать исполнение здатчиков при получении команды о прекращении текущего поведения. В случае, если такое поведение нежелательно,
то можно реализовать `on_stop` хуки со отвевающих состояний, либо выработать индивидуальную схему деактивации поведение (посылка сообщения, переключение на деактивиркющее поведение).
Задача установить правильную конфигурацию задатчиков возлагается на активируемое flexbe-поведение. 
Так, если для выполнения движения требуется принять некоторую начальную позу, то вначале должен присутствовать обращение к поведению, которое приводит робота в это состояние.

Реализация контура непрерывного управления на flexbe-состониях также довольно проста. Когда состояние активно, оно читает топик датчика, а потом публикует сообщение на топик задатчика.
Если задержка flexbe-состояния слишком велика, то может потребоваться отдельный компонент мультиплексор.

### Унификация интерфейсов задатчиков

Для эффективного использования задатчиков из поведенческих модулей предлагается:

* Обеспечить четкое разделение между типами задатчиков.
    1. **Задатчики дискретного позиционного упраления** решают задачи перевода робота в заданную позу за конечное время, используют интерфейс `actionlib`. Пример: `MoveToJointState`.
    2. **Задатчики непрерывного упраления** решают задачи слежение, используют интерфейс операций и подписку на топики. Пример: `FollowJointState`.
    3. **Задатчики программного упраления** решают задачи исполнения записанных траекторий, используют интерфейс `actionlib`. Пример: `AnimationJointTrajectory`.
        
* Обеспечить исполнения нескольких однотипных команд одновременно. Например, одновременно запускается анимация головы и одной из ног. 
    Способы достижения могут быть различны:
    1. Поддержка на  уровне задатчика нескольких действий `actionlib`. Решение плохо, т.к. требует на уровне задатчика частично реализовывать функции арбитра. Также интерфейс `actionlib` с 
        несколькими задачами достаточно сложен.
    2. Загружено несколько однотипных задатчиков, высший уровень выбирает нужный. В таком случае на высший уровень накладывается функция мониторинга задатчиков, выбора подходящего, что излишне усложняет его.
        Как наиболее простой вариант можно выделить отдельный задатчик на несколько групп ресурсов, которые могут использоваться независимо. Тогда необходимости мониторинга можно избежать.
    3. Промежуточный прокси-компонент, пересылающий сообщение инициирующее новое действие на свободный из нескольких загруженных задатчиков. Этот вариант решения требует дальнейшего исследования.
    Рекомендуется решение 3 или 2 (с выделенными задачками под группы ресурсов). Последний вариант наиболее прост в реализации, предлагается использовать его до появления серьезных проблем.

* Отказаться от концепции приоритетов задатчиков и возврата ресурсов предыдущему вадельцу. Функция арбитра --- только избегание конфликтов ресурсов.
    Функционирование уровня задатчиков должно быть наиболее просто и хорошо предсказуемо, иначе реализация поведений сильно усложняется, т.к. требуется следить за сампроизвольными переключениями.

### Супервизор для поведений FlexBe и интеграция с чатботом

Чатбот представляется возможным вариантом для реализации алгоритма выбора высокоуровневых действий. Он представляет собой систему преобразующую текст в текст.
Входным текстом является фразы людей (речь) и состояние среды и робота (идентификаторы состояний). Выходной текст --- речь робота, идентификаторы поведению и их текстовые аргументы.

**Активация поведения** происходит через [API `behavior_onboard`](http://wiki.ros.org/flexbe/Tutorials/Running%20Behaviors%20Without%20Operator). 
Для активации поведения достаточно знать его имя (идентификатор). Этот интерфейс также позволяет передавать поведения параметры, прерывать исполнение поведения.

**Представление состояния среды и робота**. Для формирования текстового описания стояния робота и внешней среды потребуется отдельный модуль. Он по показаниям 
датчиков и векторам состояния робота должен сформировать необходимое описание. Технически это модуль может быть устроен как набор экспертных систем и классификаторов,
отвечающих за различные аспекты восприятия мира роботом. Примеры: классификатор позы робота (опрокинулся, стоит, сидит, лежит), обнаружение лиц, детектор жестов LipMotion и т.п.).

Способ представления информации в виде текста может отличаться:
- Набор логических утверждений. ("свити_опрокинулась", "вижу_человека", "громкий_звук"). При необходимости утверждения снабжаются метаинформацией (например, положение человека). 
- Педикаты. ("вижу(A) & человек(A)"). Существенно более сложное представление, позволяет работать с несколькими объектами. Объекты также снабжаются метаинформацией.
Вероятно, разумно выработать некое промежуточное представление в зависимости от типа метаинформации и возможных действий объекта. 
Например: "свити_опрокинулась() & свити_ждет_помощи() & вижу_объект(мяч) & вижу_человек(mutronics)"

**Обработка объектов**. Желательно, чтобы чатбот мог отслеживать объекты, в том смысле, что реакций на "вижу(мяч) & вижу(человек)" может быть либо "следить(мяч)", либо "следить(человек)".
С "человек" и "мяч" связаны конкретные координаты, и действие слежение может быть реализовано только, если ему переданы эти координаты.
    

Альтернативный вариант интеграции  чатбота может состоять в его встраивании в некоторое поведение FlexBe в качестве состояния.
Однако в этом случае архитектура FlexBe делает сложной  реализацию асинхронного принятия решения и прерывания текущего действий. 
По этой причине вариант не рассматривается.


### Хранение описаний поведений
    * xml-описание нескольких низкоуровневых действий (как у глаз) --- подходит для описания жестких программ, сложно передавать параметры, 
         легко написать соcтяоние FlexBe, реализущее описанное действие.
    * *состояние FlexBe* --- может принимать параметры, легко интегрируется в другие поведения,
    * *поведение FlexBe* --- может принимать параметры, легко интегрируется в другие поведения.

Список низкоуровневых действий
------------------------------

Большинство низкоуровневых действий исполняются непосредственно задатчиками движений.

0. Все сочленения (включая фиктивные):
    * Поместить в заданную позу в угловой СК (без учета самопересечение и позной устойчивости). (`FollowJointState`)
    * Повторить записанное движение. (`AnimationJointTrajectory`)
1. Голова
    * Смотреть на заданный объект/в заданном направлении. Слежение за объектом/направлением. 
    * Позиционировать рот/нос в заданную точку. Слежение за заданной точкой положения нос/рта.
    * Захват объекта ртом?
3. Глаза
    * Смотреть на заданный объект/в заданном направлении. Слежение за объектом/направлением.
    * Переключение эмоционального состояния, проигрывание анимаций.
4. Одна нога
    * Поместить копыто в заданную позу. Слежение за заданной позой. (`AnimationJointTrajectory`+`move_group` или ???)
    * Силовое взаимодействие с объектом? (Надавить на заданную точку).
5. Платформа, ноги и голова
    * Поменять положение платформы при сохранении положения опорных ног.
    * Переместить платформу в заданную точку (ходьба).
    * Двигаться в заданной скоростью (ходьба, рысь).
    * Принять известную позу (стоит, сидит и т.п.)
