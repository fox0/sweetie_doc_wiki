Переключение задатчиков
=======================

Раздел описывает принципы переключения походок и анимаций.

Требования к систем переключения
--------------------------------- 

На основе базовых [требований к архитектуре](architecture) выдвигаются следующие специфичные ограничения для подсистемы переключения походок:

* Должна быть возможность переключения различных модулей-задатчиков движения (`gait_*`, `animation_*`). 
Однако способ взаимодействия с высшим уровнем не определен.

* Список компонент-задатчиков неизвестен, требуется возможность удобного добавления новых задатчиков. 
(Отсутствие сводной таблицы задатчиков, общих списков ресурсов, нужных каждому).

* Задатчик может быть запущен только в определенных условиях (позе). Должен быть механизм их проверки, по возможности, неотделимый 
от самого задатчика. Тут следует отметить, что сама логика переключения задатчиков должна учитывать зависимости. 
Однако конкретный механизм нужен для двух целей: 1) сказать высшему уровню, что переключение невозможно; 2) исключить 
переключение в некорректной позе.

* Задатчики пассивны: они запускаются только по внешнему событию (команде верхнего уровня). 

* С каждым задатчиком ассоциирован список ресурсов. Любой ресурс должен быть в эксклюзивном использовании. Однако,
    по отношению к данному задатчику ресурсы можно разделить на 2 группы:
  
    * **необходимые** --- работа задатчика невозможна/бессмысленна без обладания этим ресурсом (пример: походка и ноги),
    * **вспомогательные** --- задатчик сохраняет работоспособность и без обладания этим ресурсом (пример: походка и голова/хвост).

* Задатчик исполняется либо бесконечно долго (походка) и прерывается по внешнему событию, либо его исполнение завершается за конечное время (анимация некого действия). 

* Перехват вспомогательных ресурсов. Можно представить ситуацию, в которой один задатчик должен перехватывать ненадолго некоторый ресурс. 
Например, робот следит головой за объектом или сморит, куда идет (продолжительная работа задатчика). Запускается анимация 
"мотнуть головой", "зевок". После ее исполнения управление возвращается исходному задатчику.


Взаимодействие с высшим уровнем
--------------------------------

В целом, интерфейс подлежит определению и может быть индивидуальным для каждого задатчика.

Общая идея состоит в том, что верхний уровень в любой момент времени может активировать нужный ему задатчик и он гарантированно заработает или сообщит о невозможности запуска.
Требования указывают, что задатчики с конечным временем исполнения должны реализовывать [`ROS Action Protocol`](http://wiki.ros.org/actionlib).
Это позволяет сразу же получить операции активации, деактивации, извещения о состоянии (не получилось, в работе, завершено). 

Аналогичный подход можно использовать для задатчиков с продолжительным исполнением, однако возможны иные варианты. Здесь все зависит от характера входа задатчика.
Например, модуль походки может получать целевую позицию в абсолютных координатах, либо желаемую скорость. В последнем случае `actionlib` не так удобен,
т.к. скорость потенциально обновляется каждый цикл управления. Однако для передачи скорости можно ввести в интерфейс задатчика специальный порт.

Для осуществления проверки условий запуска без передачи управления задатчику следует ввести отдельную операцию.


Взаимодействие с подсистемой управления движения
-----------------------------------------------

* Входные порты с разного типа: текущей поза робота (желаемая или измеренная), датчики касния, прочее.

* Выходной порт с неполной желаемой позой робота в угловой СК (`JointState` или `JointLimbState`) или декартовой СК (`CartesianState`).

* Выходной порт с неполной желаемой позой робота в угловой СК (`JointState` или `JointLimbState`) или декартовой СК (`CartesianState`).


Реализация механизма переключения
---------------------------------

Код реализующий переключение имеет смысл вынести в класс-родитель для всех компонент, реализующих задатчики. 

Далее предлагается несколько вариантов реализации. Подробно расписаны только варианты без перехвата вспомогательных ресурсов.
Причина --- сложность реализации такой возможности и неясность, нужна ли она на этом уровне системы управления.
Однако тогда при активации действия с конечной продолжительностью задача восстановления состояния "как было" полностью ложится на верхний уровень.

Вероятно, **вытеснение на базе операций** --- самый адекватный вариант реализации..

#### Способ представления ресурсов

Здесь есть *альтернативы*.

1. Множество строк-имен. Процедуры проверки, передачи и прочее достаточно затратны. Универсальность и независимость от компонент.
2. Битовый вектор. Требуется общий метод трансляции битового вектора в имена (библиотека), общий список ресурсов. Удобно с точки зрения программиста.

Предлагается **первый вариант**. Он не отменяет возможность создания специального класса для ускорения операций над наборами ресурсов.

Базовая реализация: механизм вытеснения
---------------------------------------

Конкретная реализация может быть сонована на портах или операциях. 
Порты позволяют легко организовать асинхронный режим, отношение многих к монгим. 
Но при этом не позволяют удобно получать ответ на на запрос.

Эта реализация, удовлетворяющая большинству приведенных выше требований. 
но при сохранении указанных механизмов возможно их усложнение до схемы с вытесняющими приоритетами.

**Цикл функционирования задатчика**.


    nonoperational -->(ативация)--> pending -->(уведомление)--> operational --> (уведомление, деактивация )--+
        ^     ^                                 |                     ^            |                         |
        |     |                                 |                     |            |                         |
        |     +---------------------------------+                     +------------+                         |
        +----------------------------------------------------------------------------------------------------+           

* **Активация задатчика** происходит внешним воздействием (операция, сообщение) или по внутренней инициативе задатчика. 
    При активации формируется запрос на ресурсы (`ResourceList`), содержвщий список ресурсов и имя компонента, их запрашивающего.
    Запрос напраялется арбитру.

    Перед активацией по внешней команде компонент может проверить условия запуска.  Если они не удовлетворены,  то процедура не активации начинается,
    а высший уровень уведомляется о отказе (способ извещения может быть разный: результат операции, отдельным сообщением, механизм `actionlib`).


* **Арбитр**. На основе получаемых запросов и уведомлений распределяет ресурсы между известными ему компонентами. 
    Он сообщает задатчикам о изменениях наборов выделенных им ресурсов. Тригером перерасперделения ресурсов является запрос или изменение состояния какого-либо компонента.

    Возможны разные стратегии:
    1. *"Слепой" арбитр.*  Запрашиваемые ресурсы выделяются ожидающиму их компоненту, все остальные задатчики уведомляются, что им эти ресурсы не принадлежат.
    1. *"Ленивый" арбитр.*  Запрашиваемые ресурсы выделяются ожидающиму их компоненту. Уведомляются посылаются только активным (operational, pending) компонентам. 
        Задатчики должны отвечать на уведомление, чтобы арбитр знал, остаются ли они активны.
    2. *"Судья." На основе знания о наборе активных компонент, их приоритетов и запросов производит расперделение ресурсов. О изменениях уведомляются только 
        активные (`operational`) и ожидающие активации (`pending`) задатчики.
    В первых двух стратегиях все ресурсы всегда полагаются необходимыми для запрашивающих их компонент. Возможности временного перехвата управления они не предоставляют.
    Вторая стртегия более сложна, но позволяет понимать, кто активен и вежможна ее усложнегнния до третьей.
    Третья стратегия дает наибольший функционал, в частности, перехват управления может быть реализован через приоритеты.

* **Уведомление**. Получив уведомление о наборе выделенных ему ресурсов (`ResourceList`), задатчик принимает решение о изменение совего сотояния. 
    Если он ожидал активации (`pending`), то он либо активируется, либо нет, в зависимости от того, устраивает ли его полученный набор ресурсов.
    Если он был активен (`operational`), то он дективируется, если потеряны критические ресурсы, либо продолжает работу с теми, что ему выделены.
    Неактивный задатчик игнорирует уведомления.

    О своем (новом) сотоянии (активен/не активен) задатчики (включяа  неактивные) уведомляют арбитра.
    (Необходимо для "судьи", желательно для "ленивого" арбитра, "слепого" можно не уведомлять). 

* **Деактивация**. Причиной остановки активного задатчика помимо изменение набора ресурсов может стать внешнее или внутреннее событие (команда высшего уровня, окончание движения).
    Также в процессе функционирования может исчезнуть надобность в некоторых ресурсах. "Судья" должны уведомляться о таких решениях 
    (можно использовать тот же `ResourceList`, добавив соответсвующее поле), в случае "ленивого" задатчика уведомления желательны.

#### Реализация с портами

**Достоинства**:

1. Простота для схем без уведомления о изменении состояния
2. Схема способна работать в РВ с не РВ компонентами.

**Недостатки**:

1. Сложно реализовать перехват ресурсов: появляются ответы-уведомления.
0. Асинхронность: возможна ситуация, когда два задатчика одновременно думают, что активны. Длительность этого промежутка определяется временем доставки сообщений и их обработки. 
    Проблема несущественна из-за скорости этих процессов.

2. Потеря сообщений при передаче: нужная походка может не выключиться, если происходит одновременно несколько переключений (решается буферизацией сообщений).
3. Недетерминированное поведение при попытке одновременного включения конфликтующих походок (решается буфферизайией и последоватьельной обработкой запросов).
    Также ожидающий активации компонент может получить "не свое" уведомление, а от предыдущего запроса. (Решается дополнительными проверками и передачей имени компонента, пославшего запрос на ремурсы).

#### Реализация с операциями

Возможна синхронная и асинхронная. Асинхронная принципиально не отличаетсмя от портов: вместо сообщений вызовы функций.

Т.к. операция --- отношение 1:1, то необходимо зарегистрировать все компоненты у арбитра. Арбитру передаются имена компонентов, онаподключается к их интрефейсам.

Арбитр предоставляет операции:

1. `register(string name)` --- регистрация задатчика, имя компонента и операция `acquare`, реализуемая им, добавляются в список. 
    Также регистрация может быть реализована через параметры.

2. `request(ResourseList req)` --- получение запроса на ресурсы от неактивного компонента или уведомления изменении состояния (отказ от ресурса, деактивация) от активного.

Задатчик предоставляет `bool acquare(ResourseList)`, возвращает `true`, если остается активным.

**Достоинства**:

1. Синхронность: по завершению запроса код деактивации в задатчиках гарантированно выполнен.
2. Не требует надеется на буфферизацию сообщений, автоматическое последовательное выполнение.
3. Способна работать с ненадежным транспортом сообщений (ROS может потерять сообщение?)

**Недостатки**:

0. Синхронность: запрашиающий задатчик ждет завершения всех операций (решается исинхронным исполнением операции).
0. Не способна работать в РВ, если есть не РВ задатчик (синхронность).
2. Более сложная реализация, большие накладные расходы, проблемы 
3. Потенциальная опасность deadlock (синхронный вызов `request` и `OwnThread` `acquare`).


### Механизм приоритов

Запрос `ResourseList` содержит: 

1. Имя компонета
2. Его состояние (активен, запрашивает, не активен).
3. Список ресурсов
4. Приоритеты задатчика по ресурсам при захвате (`pending`)
5. Приоритеты задатчика по ресурсам в активном сотоянии (`operational`)

Приоритеты в неактивном сотоянии, очевидно, нулевые.

Арбитр сравнивает действующие приоритеты и распределяет ресурсы по активным и ожидающим выделения ресурсов задатчиками.
Тригером перерасперделения явлется запрос на ресурсы или уведомление о изменении состояния компонента (деактивация, отказ от ресурсов). 

Одно событие (запрос, уведомление о самомпроизвольной деактивации) может вызвать несколько "раундов" обменов. 
Однако, раунд либо явялется последним (все задатчики остались активными), либо на нем выбывает какой-то активный или ожидающий компонент.
Поэтому процедура завершается.

(Для "слепого" и "ленивого" арбитра раунд всегда один).








