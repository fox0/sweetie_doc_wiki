Переключение задатчиков
=======================

Раздел описывает принципы переключения походок и анимаций.

Требования к систем переключения
--------------------------------- 

На основе базовых [требований к архитектуре](architecture) выдвигаются следующие специфичные ограничения для подсистемы переключения походок:

* Должна быть возможность переключения различных модулей-задатчиков движения (`gait_*`, `animation_*`). 
Однако способ взаимодействия с высшим уровнем не определен.

* Список компонент-задатчиков неизвестен, требуется возможность удобного добавления новых задатчиков. 
(Отсутствие сводной таблицы задатчиков, общих списков ресурсов, нужных каждому).

* Задатчик может быть запущен только в определенных условиях (позе). Должен быть механизм их проверки, по возможности, неотделимый 
от самого задатчика. Тут следует отметить, что сама логика переключения задатчиков должна учитывать зависимости. 
Однако конкретный механизм нужен для двух целей: 1) сказать высшему уровню, что переключение невозможно; 2) исключить 
переключение в некорректной позе.

* Задатчики пассивны: они запускаются только по внешнему событию (команде верхнего уровня). 

* С каждым задатчиком ассоциирован список ресурсов. Любой ресурс должен быть в эксклюзивном использовании. Однако,
    по отношению к данному задатчику ресурсы можно разделить на 2 группы:
  
    * **необходимые** --- работа задатчика невозможна/бессмысленна без обладания этим ресурсом (пример: походка и ноги),
    * **вспомогательные** --- задатчик сохраняет работоспособность и без обладания этим ресурсом (пример: походка и голова/хвост).

* Задатчик исполняется либо бесконечно долго (походка) и прерывается по внешнему событию, либо его исполнение завершается за конечное время (анимация некого действия). 

* Перехват вспомогательных ресурсов. Можно представить ситуацию, в которой один задатчик должен перехватывать ненадолго некоторый ресурс. 
Например, робот следит головой за объектом или сморит, куда идет (продолжительная работа задатчика). Запускается анимация 
"мотнуть головой", "зевок". После ее исполнения управление возвращается исходному задатчику.


Взаимодействие с высшим уровнем
--------------------------------

В целом, интерфейс ожет быть индивидуальным для каждого задатчика.

Общая идея состоит в том, что верхний уровень в любой момент времени может активировать нужный ему задатчик и он гарантированно заработает или сообщит о невозможности запуска.
Требования указывают, что задатчики с конечным временем исполнения должны реализовывать [`ROS Action Protocol`](http://wiki.ros.org/actionlib).
Это позволяет сразу же получить операции активации, деактивации, извещения о состоянии (не получилось, в работе, завершено). 

Аналогичный подход можно использовать для задатчиков с продолжительным исполнением, однако возможны иные варианты. Здесь все зависит от характера входа задатчика.
Например, модуль походки может получать целевую позицию в абсолютных координатах, либо желаемую скорость. В последнем случае `actionlib` не так удобен,
т.к. скорость потенциально обновляется каждый цикл управления. Однако для передачи скорости можно ввести в интерфейс задатчика специальный порт.

Для осуществления проверки условий запуска без передачи управления задатчику следует ввести отдельную операцию.

Взаимодействие с подсистемой управления движения
-----------------------------------------------

* Входные порты с разного типа: текущей поза робота (желаемая или измеренная), датчики касния, прочее.

* Выходной порт с неполной желаемой позой робота в угловой СК (`JointState`) или декартовой СК (`CartesianState`).

* Выходной порт с опорными коэффициентами (распределение веса `SupportState`). Для анимаций выходом почти всегда будет отсутсвие касания.

Реализация механизма переключения
---------------------------------

Реализация механизма переключения включает две части:
1. Компонент-арбитр.
2. Клинетская часть (плагин, загружаемый в задатчик).

Принципиально возможно несколько реалзаций механизма переключения: 
* без распределения (задатчик всегда активен, это полезно для тестирования и отладки), 
* вытеснение ресурсов (ресурс принадлежит последнему запросившему его),
* приоритеты.
Плагины обладают единым внутренним инерфейсом (для задатчика), что позволяет использовать один задатчик с разными механизмами выделения ресурсов.

При реализации с приоритетами возникает проблема, что ресурс может быть передан только компоненту с более высоким приоритетом. 
Поэтому, например, неясно как реализоывать переключение равноправных походок. Поэтому предлагается "гибрид" приоритетов и вытеснения:
запрашиваемые ресурсы снабжаются двумя приоритетами, один используеися при запросе, а второй --- при нормальном функционировании.
Так активируемая походка может использовать высший приоритет при активации, а потом понижать его до среднего, чтобы другой 
задатчик мог перехватить уравление.


#### Способ представления ресурсов

При передачи сообщений используется список строк.
На уровне клинетов и арбитра можно использовать более эффективные сопсобы: `set`, `map`.

Базовая реализация
-----------------------------------------------

Базовая реализация основана на асинхронном обмене сообщений через порты. 
При регистрации задатчика арбитром создаются три соединения:
1. **От задатчика к арбитру** (`ResourseRequest`): список желаемых ресурсов и их приоритеты в разных сотояниях.
    
    string[] resource       
    float[] pri_operational
    float[] pri_pending

1. **От задатчика к арбитру** (`ResourseRequesterState`): сотояние задатчика.

    bool is_operational

1. **От арбитра к задатчику** (`ResourseList`): отношение ресурсов-задатчик.

    string[] resource
    string[] owner

### Логика работы клиентской части

Задатчик может быть в 3-х состояних: активн (operational), запрос ресурсов (pending), неактивен (nonoperationl).

* **Активация задатчика** происходит внешним воздействием (операция, сообщение) или по внутренней инициативе задатчика. 

    Перед активацией по внешней команде компонент проверяет условия запуска.  Если они не удовлетворены,  то процедура активации не начинается,
    а высший уровень уведомляется о отказе (способ извещения может быть разный: результат операции, отдельным сообщением, механизм `actionlib`).

    Если условия запуска удовлетворены, то компонент переводится в состояние "pending", формируется сообщение `ResourseRequest`. 
    Указываются запрашиваемые ресурсы (протейшая реализация) и их приоритеты для сотояний "активен" и "pending" (реализация с приоритетами).

* **Изменение выделенного набора ресурсов**. Обработка входящих сообщений `ResourseList` происходит только в состоянии "активен" или "pending".
    При получении на входной порт списка выделенных ресурсов он обрабатывается и принимается решение, может ли компонент продолжать работу. 
    Если работа может быть продолжена, то сотояние остается "активен" (или меняется c "pending" на "активен"), иначе осуществляется деактивация.
    В любой ситуции получение подтверждается посылкой `ResourseRequesterState` c новым сотоятнием компонента.

* **Деактивация задатчика** моежет происходить по внутренней инициативе или внешнему событию (в частности, изменению списка ресурсов). 
    При этом формируется соответвующий `ResourseRequesterState` с состоянием "не активен". 

* **Пользовательский код** вызывается только в состоянии активен.

### Логика работы арбитра

Арбитр обрабатывает поступающие сообщения асинхронно. Однако он хранит:

* Состояния компонент:
     * активен/ожидает активации/не активен
     * список выделенных ресурсов
     * желаемый набор ресурсов и их приоритеты (по `ResourseRequest`)

* Состсояние раунда обработки `ResourseRequest`:
     * компоненты, от которых ожидается ответ в раунде
     * timeout раунда


Перераспрелделение ресурсов происходит в виде раундов. Раунд начинается по событию получения `ResourseRequest`, Паралельно может идти несколько раундов. 

В рамках одного раунда происходят следующие действия:

1. **Обработка запроса ресурсов**. По событию `ResourseRequest`:
     * Обрабатывается пришедший `ResourseRequest`: обновляется состояние компонента 
         (статус --- ожидает активации, список желаемых ресурсов, приоритеты).
     * Происходит перераспределение ресурсов по приоритетам, компоненты ожидающие активации (с обрабатываемыми `ResourseRequest`) используют приоритеты состояния 
         "pending", активные --- "активен", не активные не участвуют в перераспределении.
     * Формируется сообщение сообщения `ResourseList`, упомянутые в нем задатчики помещаются в список, от которых ожидается ответ в раунде, устанавливается таймер.

2. **Обработка извещения о деактивации и подтверждений продолжения работы с выденнным списком ресурсов**. По событию `ResourseRequesterState`:
     * Если задатчик остается активен, то это означает, что он подтверждает набор выделенных ему ресурсов. Он удаляется из списка компонент, от которых ожидается ответ.
     * Если задатчик деактивируется, то	повторяется процедура перераспределния ресурсов для оставшихся компонент. Снова формируются `ResourseList` 
         и соответвующие задатчики помещаются в список компонент, от которых ожидается подтверждение.
     * Если список компонент, от которых ожидатся подтверждение, пусть то раунд считается завершенным. Состояния "pending" меняется на "активный".  

3. **Принудительное завершение раунда**. По timeout:
     * Раунд завершен принудительно: состояния "pending" меняется на "активный", список ожидаемых ответов очищается.

**Замечание**: Возможна одновремнная обработка запросов, пришедших быстро друг за дргугом: несколько компонент могут быть в состоянии "pending". 
Другая вариация этого механизма --- не начинать  обработку нового, до завершения рацнда. Следует отметить, что результат распределния потенциально будет отличаться,
в зависимости от выбранного механизма. 

**Замечание**: Возможна ситуция, когда одновременно активны два компонента, использующие один ресурс. Однако его длительность будет состоявлять не более одного цикла управления. 
Считаю, что это не вызовет проблем, т.к. задания на приводы не должны меняться быстро при переключении. Реализация исключающее это должна блокировать исполнение ожидающего 
активации компонента до конца раунда. По моему мнению, это опаснее для РВ.

**Замечание**: Реализация без приоритетов проще, фактически это часть версии с приоритетами:
     * приоритеты не нужны, необходимость контроля раунда исчезает, как и связанные переменные;
     * распределние ресурсов сводится к отъему у активных компонент нужных запрашивающему ресурсов;
     * по сообытию деактивации компонента ресурсы возвращаются активным компонентам просто в порядке их следования в списке.

**Замечание**: Для передачи сообщенией `ResourseRequest`, `ResourseList` и `ResourseRequesterState` можно использовать одно сообщение, просто объединив их поля и 
не заполняя ненужные поля при передаче. Однако делать это имеет смысл только для `ResourseRequesterState`  и `ResourseRequest`, чтобы сократиь число портов и упростить развертывание.


#### Реализация с портами

**Достоинства**:

1. Простота для схем без уведомления о изменении состояния
2. Схема способна работать в РВ с не РВ компонентами.

**Недостатки**:

1. Сложно реализовать перехват ресурсов: появляются ответы-уведомления.
0. Асинхронность: возможна ситуация, когда два задатчика одновременно думают, что активны. Длительность этого промежутка определяется временем доставки сообщений и их обработки. 
    Проблема несущественна из-за скорости этих процессов.

2. Потеря сообщений при передаче: нужная походка может не выключиться, если происходит одновременно несколько переключений (решается буферизацией сообщений).
3. Недетерминированное поведение при попытке одновременного включения конфликтующих походок (решается буфферизайией и последоватьельной обработкой запросов).
    Также ожидающий активации компонент может получить "не свое" уведомление, а от предыдущего запроса. (Решается дополнительными проверками и передачей имени компонента, пославшего запрос на ремурсы).

#### Реализация с операциями

Тот же механизм может быть реализован на база операций. При этом обмер `ResourseList`--`ResourseRequesterState` заменяется вызовом одной операции.

Арбитр предоставляет операции:

1. `register(string name)` --- регистрация задатчика, имя компонента и операция `acquare`, реализуемая им, добавляются в список. 
    Также регистрация может быть реализована через параметры.

2. `request(ResourseList req)` --- получение запроса на ресурсы от неактивного компонента или уведомления изменении состояния (отказ от ресурса, деактивация) от активного.

Задатчик предоставляет `bool acquare(ResourseList)`, возвращает `true`, если остается активным.

**Достоинства**:

1. Синхронность: по завершению запроса код деактивации в задатчиках гарантированно выполнен.
2. Не требует надеется на буфферизацию сообщений, автоматическое последовательное выполнение.
3. Способна работать с ненадежным транспортом сообщений (ROS может потерять сообщение?)

**Недостатки**:

0. Синхронность: запрашиающий задатчик ждет завершения всех операций (решается исинхронным исполнением операции).
0. Не способна работать в РВ, если есть не РВ задатчик (синхронность).
2. Более сложная реализация, большие накладные расходы, проблемы 
3. Потенциальная опасность deadlock (синхронный вызов `request` и `OwnThread` `acquare`).


### Механизм приоритов

Запрос `ResourseList` содержит: 

1. Имя компонета
2. Его состояние (активен, запрашивает, не активен).
3. Список ресурсов
4. Приоритеты задатчика по ресурсам при захвате (`pending`)
5. Приоритеты задатчика по ресурсам в активном сотоянии (`operational`)

Приоритеты в неактивном сотоянии, очевидно, нулевые.

Арбитр сравнивает действующие приоритеты и распределяет ресурсы по активным и ожидающим выделения ресурсов задатчиками.
Тригером перерасперделения явлется запрос на ресурсы или уведомление о изменении состояния компонента (деактивация, отказ от ресурсов). 

Одно событие (запрос, уведомление о самомпроизвольной деактивации) может вызвать несколько "раундов" обменов. 
Однако, раунд либо явялется последним (все задатчики остались активными), либо на нем выбывает какой-то активный или ожидающий компонент.
Поэтому процедура завершается.

(Для "слепого" и "ленивого" арбитра раунд всегда один).








