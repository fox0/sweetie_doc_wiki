Переключение задатчиков
=======================

Раздел описывает принципы переключения походок и анимаций.

Требования к систем переключения
--------------------------------- 

На основе базовых [требований к архитектуре](architecture) выдвигаются следющие 
специфичные ограничения для подсистемы переключения походок:

* Должна быть возможность переключения различных модулей-задатчиков движения (`gait_*`, `animation_*`). 
Однако способ взаимодействия с высшим уровнем не определн.

* Список компонент-задатчиков неизвестен, требуется возможность удобного добавления новых задатчиков. 
(Отсутсвие сводной таблицы задатчиков, общих списоков ресурсов, нужных каждому).

* Задатчик может быть запущен только в опредленных условиях (позе). Должен быть механизм их проверки, по взможности, неотделимый 
от самого задатчика. Тут следует отметить, что сама логика переключения задатчиков должна учитывать зависимости. 
Однако конкретный механим нужен для двух целей: 1) сказать высшему уровню, что переключение невозможно; 2) исключить 
переключение в некорректной позе.

* Задатчики пассивны: они запускаются только по внешнему событию (команде верхнего уровня). 

* С каждым задатчиком ассоциирован список ресурсов. Любой ресурс должен быть в эксклюзимном использовании. Однако,
    по отношению к данному задатчику ресурсы можно разделить на 2 группы:
  
    * **необходимые** --- работа задатчика невозможна/бессмвсленна без обладания этим ресурсом (пример: походка и ноги),
    * **вспомогательные** --- задатчик сохраняет работспособность и без обладания этим ресурсом (пример: походка и голова/хвост).

* Задатчик исполняется либо бесконечо долго (походка) и прерывается по внешнему событию, либо его исполнение завершается за конечное время (анимация некого действия). 

* Перехват вспомогательных ресурсов. Можно представить ситуацию, в которой один задатчик должен перехватывать ненадолго некоторый ресурс. 
Например, робот следит головой за объектом или сморит, куда идет (продолжительная работа задатчика). Запускается анимация 
"мотнуть головой", "зевок". После ее исполнения управление возвращается исходному задатчику.


Взаимодействие с высшим уровнем
--------------------------------

В целом, интерфейс подлежит определнию и может быть индивидуальным для каждого задатчика.

Общая идея состоит в том, что верхний уровень в любой момент времени может активировать нужный ему задатчик и он гарантированно заработает или сообoщит о невозможности запуска.
Требования указывают, что задатчики с конечным временем исполнения должны реализовывать [`ROS Action Protocol`](http://wiki.ros.org/actionlib).
Это позвояет сразу же получить операции активации, деактивации, извещения о состоянии (не получилось, в работе, завершено). 

Аналогичный подход можно использовать для задатчиков с продолжительным исполнением, однако возможны иные варианты. Здесь все зависит от характера входа задатчика.
Например, модуль походки может получать целевую позицию в абсолютных координатах, либо желаемую скорость. В последнем случае `actionlib` не так удобен,
т.к. скорость потенциально обновляется каждый цикл управления. Однако для передачи скорости можно ввести в интерфейс задатчика специальный порт.

Для осуществления проверки условий запуска без передачи управления задатчику следует ввести отдельную операцию.


Взаимодействие с подсистемой управления движения
-----------------------------------------------

* Входные порты с разного типа: текущей поза робота (желаемая или измеренная), датчики касния, прочее.

* Выходной порт с неполной желаемой позой робота в угловой СК (`JointState` или `JointLimbState`) или декартовой СК (`CartesianState`).

* Выходной порт с неполной желаемой позой робота в угловой СК (`JointState` или `JointLimbState`) или декартовой СК (`CartesianState`).


Реализация механизма переключения
---------------------------------

Код реалищующий переключение имеет смысл вынести в класс-родитель для всех компонент, реализующих задатчики. 

Далее предлагается несколько вариантов реализации. Подробно расписаны только варианты без перехвата вспомогательных ресурсов.
Причина --- сложность реализации такой возможности и неясность, нужна ли она на этом уровне системы управления.
Однако тогда при активации действия с конечной продолжительностью задача востановления состояния "как было" полностью ложится на верхний уровень.

Вероятно, **вытеснение на базе операций** --- самый адекватный вариант реализации..

#### Способ представления ресурсов

Здесь есть *альтернативы*.

1. Множество строк-имен. Процедуры проверки, передачи и прочее достаточно затратны. Универсальность и независимость от компонент.
2. Битовый вектор. Требуется общий метод трансляции битового вектора в имена (библиотека), общий список ресурсов. Удобно с точки зрения программиста.

Предлагается **первый вариант**. Он не отменяет возможнось создания специального класса для ускорения операций над наборами ресурсов.

Базовая реализация: механизм вытеснения (порты)
-----------------------------------------------

Это наиболее простая реализация, удовлетворяющая большенству приведенных выше требований. 
Она не обеспечивает возможность перехвата вспомогательных ресурсов, т.е. все ресурсы предполагаются необходимыми.

Взаимодействие осуществляется сообщениями `ResourceRequest`. Каждый задатчик снабжен входным и выходным портом 
этого типа. Если один из них формирует `ResourceRequest`, он через компонент `resourse_control` передается всем другим задатчикам.

* **Активация задатчика** происходит внешним воздействием (операция, сообщение). Компонент проверяет условия запуска. 
Если они не удовлетворены,  осуществляется извещение о неудаче (способ извещения может быть разный результат операции, отдельным сообщением, механизм `actionlib`).
Иначе формируется сообщение `ResourceRequest` со списком необходимых активируемому задатчику ресурсов. Активация сичтается успешной при получении эха собственного сообщения 
`ResourceRequest` от компонента `resourse_control` и неуспешной по истечению некоторого промежутка времени.


* **Деактивация задатчика** происходит по внешнему событию (команда с высшего уровеня), внутреннему событию (конец движения) или в результате вытеснения другим задатчиком.
Механизм вытеснения работает следующим образом: задатчик деактивируется, если  получает сообщение `ResourceRequest`, удовлетворяющее следующим условиям 
1) в нем запрашиваются ресурсы, используемые данным задатчикм, 2) сообщение было послано не им (поле `name` содержит имя отличное от имени задачика).

* Компонент **`resourse_control`** формирует эхо полученных сообщений.

**Достоинства**:

1. Простота.
2. Схема способна работать в РВ с не РВ компонентами.

**Недостатки**:

1. Не реализует временный перехват ресурсов.
0. Асинхронность: возможна ситуация, когда два задатчика одновременно думают, что активны. Длительность этого промежутка определяется временем доставки сообщений и их обработки. 
    Проблема несущественна из-за скорости этих процессов.

2. Потеря сообщений при передаче: нужная походка может не выключиться, если происходит одноверменно несколько переключений (решается буфферизацией сообщений).
3. Недетерминированное поведение при попытке одновременного включения конфликтующих походок (решается буфферизайией и активацией только по получению эха `ResourceRequest`).

Недетерминированность решается буфферизацией. В правильной реализации активируется задатчик, пославший сообщение запроса последним.
Переполнение буффера сообщений (потеря сообщения) приводит к недеретминированному поведению. Если компонент послал запрос на активацию,
то он должен игнорировать входящие `ResourceRequest`, пока не получет эхо своего запроса, либо истечет период ожидания.

Базовая реализация: механизм вытеснения (операции)
--------------------------------------------------

Тот же механизм может быть реализован на база операций. Синхронная природа операций приводит к исключению потери сообщений и гарантированной 
активайции компонента, последним вызвавшем операцию.

Задатчики предоставляют операцию `release(const ResourseRequest&)`, семантика которой совпадает с получением сообщения `ResourseRequest`.

`resource_control` предоставляет операции:

1. `register(string name)` --- регистрация задатчика, имя компонента и операция `release`, реализуемая им, добавляются в список. 
    Также регистрация может быть реализована через параметры.

2. `request(ResourseRequest req)` --- эквивалент эха. Последовательно вызываются операции `release` для всех зарегистрированных компонент,
    кроме вызвавшего операцию (он передает свое имя в `req.name`). 

Логика работы аналогична реализации с портами. Посылки сообщения `ResourseRequest` соответсвует вызов `request`, после которого ресурсы можно считать захваченными.
Получению сообщения `ResourseRequest` --- вызов `release`, который приводит к деактивации компонента при конфликте.

**Достоинства**:

1. Синхронность: по завершению запроса код деактивации в задатчиках гарантированно выполнен.
2. Не требует надется на буфферизацию сообщений.
3. Способна работать с ненадежным транспортом сообщений (ROS может потерять сообщение?)

**Недостатки**:

0. Синхронность: запрашиающий задатчик ждет завершения всех операций. 
0. Не способна работать в РВ, если есть не РВ задатчик (синхронность).
1. Не реализует временный перехват ресурсов.
2. Более сложная реализация, большие накладные расходы.
3. Потенциальная опасность deadlock при неправильном задании имени запрашивающего ресурсы компонената.

Недостатоки синхронности может быть снят, если извещать только активные задатчики (сохраняются проблемы РВ),  
либо использовать метод `send` (теряется синхронность).

Реализация с возможотью перехвата ресурсов: приоритеты для `resource_control`
--------------------------------------------------------------------------

Идея --- при запросе `ResourceRequest` ассоциировать с каждым вспомогательным ресурсом приоритет. 
Управление получает компонент с высшим приоритетом. Тогда временный перехват становится возможным.

Реализация такого подхода требует многоступенчатой процедуры обмена сообщениями, для выявления победителя.
Процедура повторяется при освобождении ресурса. Требуются средства управления приоритетами ресурсов задатчиков.

Кроме того, основной код задатчика должен учитывать, каким набором ресурсов он владеет в данный момент.

*Верояный вердикт*: слишком сложно.


Реализация с возможотью перехвата ресурсов: приоритеты для `agregator_`
-----------------------------------------------------------------------

В выходные сообщения задатчиков `JointLimbState`, `CartesianState` и др. к каждому ресурсу добавляется поле проритета.
`agregator_*` выбирает сообщения с наибольшим приоритетом. В рамках такого механизма нужным назначением приоритетов 
можно реализовать временный перехват ресурса.

Для безусловного захвата ресурса требуется либо вводить систему динамических приоритетов, либо использовать описанный выше 
механизм вытеснения.

*Верояный вердикт*: сложно, выглядит как костыль, требует модификации сообщения задатчиков (или иных способов сообщения агрегатору о приоритетах),
требует использования варианта архитектуры `JointLimbState`.






