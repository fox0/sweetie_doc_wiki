Задатчик `ExecuteStepSequence`
----------------------------------------------------------------

Задатчик исполняет действие `FollowStepSequence` описывающее последовательность шагов робота (траектория основания, траектории ног, признаки контактов).
Предназначен для интеграции с генератором походки TOWR. В режиме сшивки траекторий позволяет добавить новую траекторию к старой,
тем самым получить непрерывную походку. Возможно исполнение записанных действий.

На текущий момент аппроксимации тракторий не предусмотрено, поэтому они должны задаваться с шагом равным циклу исполнения задатчика.

### Входные порты

1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.

1. `in_limbs_fixed` (`RigidBodyState`) --- состояние робота в декартовой системе (положение конечностей относительно основания), порядок не должен меняться.

1. `in_base` (`RigidBodyState`) --- состояние основания относительно неподвижной СК.

1. `in_balance` (`BalanceState`) --- информация о равновесии (формируется модулем динамики).


### Выходные порты

1. `out_base_ref` (`RigidBodyState`) --- выход задатчика --- положение основания относительно неподвижной СК (для переопределения одометрии).

1. `out_limbs_ref` (`RigidBodyState`) --- выход задатчика --- положение конечности в декартовой СК относительно основания, оно передается модулю обратной кинематики.

1. `out_supports` (`SupportState`) --- информация о контактах. 

### Параметры


### Операции

1. Требует: `bool poseToJointStatePublish(const RigidBodyState& pose)` --- синхронный вызов обратной кинематики. Для того 

### Сервисы 

2. Требует: сервис `robot_model`.
2. Требует (опционально): сервис `FilterRigidBodyState` --- используется для плавного сопряжения позы с текущей.

### Действия

1. Сервер `sweetie_bot_kinematics_msgs/FollowStepSequence` --- последовательность шагов для исполнения.

### Семантика исполнения

Траектории могут не содержать ориентации конечностей, тогда она предполагается нулевой (направлено вниз).

**Получение нового задания**: 
* новая траектория:
    1. проверить корректность сообщения
    2. проверить условия запуска (ограничения по расхождению позиции)
	3. кэшировать траекторию (ошибка --- переполнение буфера)
	4. запросить нужный набор ресурсов
* продолжение старой
    1. проверить корректность сообщения
    2. проверить условия запуска: совпадение конца старой и начала новой, время. Второй вариант --- продолжение с любого момента.
	3. кэшировать траекторию (ошибка --- переполнение буфера)
	4. считать предыдущее действие успешным, принять к исполнению новое действие, соответствующее объединенной траектории.

**Поведение сервера действий**:
* Получение новой траектории пока не обработана старая: REJECT или не активировать ее до завершения движения.
* Прерывание исполнения траектории: выполняется немедленно.
Т.к. походка потенциальна неустойчива, формируется с задержкой, то переключится на другое движение не представляется возможным.
Механизм продолжения должен позволят заменить/продолжить одно движение другим. Новая же цель должна отвергаться, т.к. непонятно, 
как сшивать ее со старой.


**Исполнение**: 
* используя кешированную траекторию и прошедшее время, определить желаемую позицию, 
* проверить:
    * что не превышены ли допустимые отклонения от траектории -> останов
    * что контакты продетектированы -> останов, если включено детектирование контактов.
	* условия равновесия (?) -> предупреждение?


**Прерывание текущего движения**. Возможны разные стратегии:
1. Прервать немедленно. При этом робот может потерять равновесие.
2. Дождаться исполнения условий равновесия и остановиться. Возможны рывки и потеря равновесия при остановке.
3. Дополнить траекторию движения последовательность остановки. Это может быть реализовано на уровне компонента формирующего задание.
1 и 2 реализуются на уровне задатчика. В целях безопасности должна быть возможность активировать оба уровня остановки,
либо переходить от стратегии 2 к 1 можно по timeout.

### Детали реализации

Основной вопрос --- как организовать буффер траектории, так чтобы миминизировать накладные расходы и допустить дальнейшее применение сплайнов:
* возможность сшивки траекторий --- требует отдельного буфера для ее хранения.
* перспективная поддержка сплайнов --- формировать буфер по получению сообщения.
* минимизировать обработку полученного сообщения --- использовать наиболее близкое представление к полученному соообщению или вынести обработку в updateHook().
Форма представления в буфере должна определяться удобством обработки (использовать типы KDL, за исключением, быть может, матриц вращения).

**Недостаток**: при уменьшении периода дискретизации растут расходы на копирование и хранение траектории. По идее нужен механизм, который бы мог добавлять дискреты,
т.е. возможность интерполяции.

Предлагаемый вариант --- аналог `JointTrajectoryCache`, однако приближение каждого элемента траектории (тело, ноги) выполняется независимо.
1. Поза твердого тела с ориентацией --- тело.
2. Поза твердого тела без ориентации --- ноги.
2. Вектор общего назначения (поза в угловой СК).
3. Вектор признаков.
Внутренне эти элементы представляют собой циклический буфер с линейной или эрмитовой интерполяцией. Для интерполяции кватернионов используется SLERP.
Циклический буфер реализуется двумя курсорами: нижним (выбор точек) и верхним (добавление точек). Наиболее подходящий кандидат --- `boost::cyclic_buffer` или `stl::deque`.

### Ошибки и исключения

Ошибки:
1. Лимиты допустимых ошибок превышены.
2. Ошибка кинематики.

Предупреждения:
1. Получение некорректных сообщений.
1. Изменение структуры сообщения `in_limbs`.


Компонент `towr_control`
-----------------------

Нода ROS, предназначенная для формирований походок различного типа и управления задатчиком `ExecuteStepSequence`.
Получает команды "переместить основание в заданную позу", "переставить ноги в заданные точки", 
т.е. фактически выступает аналогом MoveIt! 

Предполагается реализация в несколько этапов:
1. Переместить основание в заданную точке (`move_base_msg/MoveBase` action).
2. Принять заданную позу (действие на базе `xpp_msgs/RobotStateCartesian`)
3. Действия аналогичные `AutoBase` для `free_gait`?

### Упрощенная кино-динамическая модель

Кинематика:
1. Базовое положение ног и ограничивающие or для их движения. Рассчитывается вручную, загружаются через параметры из конфигурационного файла.

Динамика:
1. Масса и тензор инерции платформы --- весь набор конечностей и основание, что остается неподвижным в процессе движения. 
2. Массы конечностей --- для упрощения предполагается, что масса ног сосредоточена в их концах.
Динамическая модель рассчитывается автоматически по URDF c использованием RBDL или KDL.

### Интерфейс компонента

**Подписка**:

1. `joint_state` (`sensor_msg::JointState`) --- текущая поза робота (необходима для расчета динамики).
1. `tf` или `robot_pose` и `base_pose` (`RigidBodyState`)  --- текущая поза робота.
1. `terrain` (`xpp_msg::TerrainInfo`) --- информация о окружающей территории.

**Публикация**:

2. `trajectory` (`xpp_msgs::RobotStateCartesianTrajectory`) --- результирующая траектория
2. `robot_param` (`xpp_msgs::RobotParameters`) --- упрощенная модель робота.

**Действия**:

1. Сервер: `move_base` (`sweetie_bot_kinematics_msgs::MoveBase`) --- запрос на передвижение робота.

**Параметры**:

1. `robot_description_dynamics` (`string`) ---  URDF модель робота.
2. `robot_model` (`map`) ---  информация о кинематических цепочках (выгруженные вызовом `setParam` декларации RobotModel).
3. Список опорных ног и описание их кинематики.
         
		  supports
		  |- leg1
		  |  |- base_pose: { x, y, z }
		  |  \- bounding_box: { x1, y1, z1, x2, y2, z2 }
		  |- leg2
		  | ...

4. Настройки походки? 

### Семантика исполнения

**Поведение сервера действий**:
1. Запросы полученные до достижения текущей цели прерывает текущий запрос.
2. Текущий запрос может быть прерван по просьбе клиента.


**Исполнение действий**:
1. Получить запрос, проверить на адекватность.
2. Составить план, если исполнение невозможно, то отвергнуть его.
3. Передать план на исполнение.
4. Мониторинг исполнения плана: детектирование завершения, при ошибке остановить исполнение.

Таким способом могут быть обработаны незначительные смешения. Однако при движении на большие расстояния требуется уметь дополнять план новыми.
Тогда система должна получить план движения, он разбивается на сегменты, задача решается на каждом из них, в процесе мониторинга, план движения дополняется.
Сформировать план движения можно используя MoveIt! или `move_base`.


### Детали реализации

В качестве основы можно взять `towr_ros`. Однако потребуется ряд изменений к библиотеке `towr`.
* Необходима возможность задавать ограничения для конечностей, используя тот же механизм, что и для указания положения платформы. (См. `nlp_formulation.cc`)
* Необходима возможность управление характером ограничений (только на X,Y или на X,Y,Z). 
* Исходная модель робота не допускает, чтобы  ограничивающие параллепипеды ног были произвольно смещены относительно номинальной позы (ноги прямо вниз). 
    Предлагается обходить это ограничение, путем изменения номинальной позы.
* Нужно создать модель робота и генератор последовательностей шагов для него.

### Исключения и ошибки

Информирование через actionlib.

Ошибки:
* Некорректный запрос
* Некорректная модель робота
* Не могу построить план
* План не исполнен.

