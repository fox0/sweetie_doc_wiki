Подсистема исполнения сохраненных движений
===========================================

Подсистема включает в себя интерактивные средства построения траекторий в угловой СК путем задания последовательности конрольных точек 
и задатчики системы управления движением, исполняющие эти траектории.

Эти возмжности в осоновном необходимы для создания анимаций. Сначала робот "обучается" движению путем помещения в ключевые позы,
а затем это движение проигрывается задатчиком по текстовому идентификатору. 

Требования
----------

1. Проигрывание траекторий заданных в угловой СК (на уровне `JointState`) в разных вариантах:
    * траектория передается в виде сообщения,
    * траектория передается в виде сообщения с дополнительной информацией о действиях, задаваемых текстовыми идентификаторам (смена анимации глаз, проигрывание звуков),
    * траектория хранится в файле (с доп. действиями или без) исполняется по сообщению с указанием ее идентификатора.

2. Частичная или полная интеграция с [MoveIt!](http://moveit.ros.org): исполнение траекторий, сохранение их.
    В перспективе использование ее средств для проверки столкновений.

3. Интерактивные средства создания траекторий, путем указания контрольных точек в угловой СК и времени исполнения. 
    Траектории могут снабжаться информацией о дополнительных действиях. 
    * Возможность работы только с моделью робота (траектория исполняется в `rviz`, контрольные точки задаются средствами ROS).
    * Возможность работы с роботом (траектория исполняется роботом, контрольные точки задаются позой).
    * Любое сочетание этих режимов.
    * Формирование файлов с сохраненными траекториями для последующего исполнения задатчиками.

Архитектура подсистемы
-----------------------

Для управления движением используются действия `actionlib`.
Это наиболее полно соответствует конечному характеру траектории, позволяет контролировать и прерывать ее исполнение.

### Базовый вариант (без поддержки текстовых действий)

Базовый вариант системы включают два типа задатчиков:
* `AnimationJointTrajectory` --- исполнение действия `control_msgs::FollowJointTrajectory`. 
* `AnimationStoredJointTrajectory` --- загружает траектории в виде сообщений `control_msgs::FollowJointTrajectoryGoal` из файлов, 
    исполняет нужную по текстовому действию `TextAction`.
Первый задатчик используется в основном для интерактивного построения траектории и интеграци с MoveIt!. Построенные траектории сохраняются в файлы, чтобы потом исполняться
при помощи `AnimationStoredJointTrajectory`.

Оба задатчика поддерживают сопряжение траекторий (за счет [механизма фильтров](library-filters) для `JointState`), отмену исполнения траектории,
переключение на другую траекторию. Набор необходимых ресурсов определяется по списку сочленений при помощи плагина [`RobotModelURDF`](plugin-robotmodel).
Полученная или загруженная траектория приближается сплайнами второго порядка.

На стороне высокого уровня могут функционировать следующие компоненты:
* Подсистема [MoveIt!](http://moveit.ros.org), она способна передавать команды в форме действий `control_msgs::FollowJointTrajectory`.
* Компонент `joint_trajectory_editor`, выполняющий роль GUI для создания траекторий. Его центральный элемент --- список контрольных точек. 
   Он предоставляет пользователю следующие возможности:
   * Редактирование: добавление в список точки (виртуального или реального робота), назначение `time_from_start` для точек, редактирование заголовка `FollowJointTrajectory`.
   * Сохранение траектории в файл.
   * Команды: послать траекторию на исполнение виртуальному или реальным роботом, отключить/включить приводы, отключить/включит исполнение траектории  робота.
     
Ниже приведена структурная схема системы, используемой для интерактивного построения траекторий: 

![arch-joint-trajectory.png](arch-joint-trajectory.png)

Она включает с себя 3 подсистемы:  реальный робот (`sweetie_bot`), виртуальный робот (`sweetie_bot_virtual`), средства отображения и редактирования траектории (`hmi`).
Редактор траекторий `joint_trajectory_editor` занимает центральное место в схеме. Он может передавать траекторию на исполнение виртуальному или реальному роботу,
устанавливать позу виртуального (`joints_virtual_set`), включать\выключать приводы реального робота (`setAllServosTorque`, `setRegisterRAM`), что позволяет менять позу вручную, 
Редактор добавлять в свой список контрольных точек новые с топиков `joints_real`  и `joints_virtual`.
(Названия топиков сокращены, реальные названия в соответствие с правилами именвания будут: `/sweetie_bot_vitrual/motion/agregator_ref/in_joints`, 
`/sweetie_bot_vitrual/motion/agregator_ref/out_joints` и `/sweetie_bot/motion/agrgator_real/out_joints`).

При использовании траекторий с информацией о дополнительных командах меняется тип действий `follow_trajectory_action`.

В виртуальную подсистему включена `moveit_group` и `joint_state_publisher`. Через соответсвующие задатчики (`FollowJointState` и `AnimationJointTrajectory`) 
они могут управлять положением виртуального робота. Используя их интерфейсы пользователь может помещать виртуального робота в позы, по которым осоздаются контрольные точки.

Хранение траекторий предлагается осуществлять за счет встроенных средств [cериализации ROS](http://wiki.ros.org/roscpp/Overview/MessagesSerializationAndAdaptingTypes). 
Альтернативой могут выступать средства сериализации OROCOS ([`boost::serialization`](http://www.boost.org/doc/libs/1_63_0/libs/serialization/doc/tutorial.html)).
В одном файле --- одна траектория, имя файла выступает в качестве идентификатора движения. 
Недостатком такого подхода является сложность с добавлением описания к траектории.

### Типы данных

Подробнее в [типы данных](message-types)

* **Траектория в угловой системе координат**
    * `control_msg::FollowJointTrajectoryGoal` --- траектория в угловой СК с информацией о требованиях к ее исполнению.
    * `control_msg::FollowJointTrajectory` --- действие `actionlib` по исполнению траектории в угловой СК.

* **Текстовое действие**
    * `TextCommand`* --- базовая текстовая команда.
    * `TextCommandStamped`* --- текстовая команда, привязанная ко времени. 
    * `TextAction`* --- текстовое действие `actionlib`.

* Траектория в угловой СК с текстовыми действиями
    * `FollowJointTrajectoryWithActions`  --- действие `actionlib` для траектории с информацией о дополнительных действиях. 
    * `FollowJointTrajectoryWithActionsGoal`  --- траектория в угловой СК и информацией о дополнительных действиях.


Задатчик `AnimationJointTrajectory` (исполнение действия `FollowJointTrajectory`)
----------------------------------------------------------------

Задатчик исполняет траекторию переданную в `FollowJointTrajectoryGoal`. 
Варианты использования:
* интеграции с MoveIt!, 
* исполнения отдельных "безымянных" траекторий,
* как часть ситемы интерактивного построения траекторий движения (анимация).

### Входные порты

Синхронизация

1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.

Текущее состояние робота

1. `joints_sorted` (`JointState`) --- состояние робота в угловой СК (желаемая или реальная по датчикам), сообщение отсортировано по кинематическим цепочкам.

### Выходные порты

Поза робота (gait)

1. `ref_joints` (`JointState`) --- задающее воздействие в угловой системе координат.
1. `ref_support` (`SupportState`) --- ожидаемое распределение веса, всегда ноль для управляемой конечности.

### Параметры

Возможны параметры настройки системы сопряжения траекторий.

### Операции

1. Предоставляет: действие `control_msg::FollowJointTrajectory`.
2. Требует: сервис `robot_model`.

### Семантика исполнения

**Получение нового задания**: 
* проверка условий запуска (поза робота в пределах лимитов из задания), 
* прерывание старого задания,
* построение сплайна по полученной траектории, 
* используя сервис `robot_model` определяет набор нужных ресурсов, запрашивает ресурсы.

**Исполнение**: 
* проверяет, что не нарушены лимиты отклонения от траектории, 
* используя кешированный сплайн и прошедшее время, определяет желаемую позицию, 

### Детали реализации

Т.к. компоненты задатчиков будут иметь общий код, то рекомендуется вынести его в родительский класс `AnimationJointTrajectoryBase`, 
общий для всех задатчиков.

После получения задания траекторию и ее лимиты лучше кэшировать в удобную структуру. В частности, может понадобится переупорядочивание звеньев, в соответствии с принятым порядком.

Для интерполяции предлагается использовать [`alglib`](http://www.alglib.net/interpolation/spline3.php) ([`tinyspline`](https://github.com/retuxx/tinyspline) 
не подходит, т.к. не обеспечивает неравномерные временные интервалы. **Проверить!**).

Лучше использовать алгоритмы [сопряжения  траекторий](library-filters) второго порядка. Реализация должна подразумевать возможность 
легкой замены алгоритма сопряжения, выбора его через параметры, передача параметров ему. Открыт вопрос использования сервиса OROCOS.


### Ошибки и исключения

Предупреждения:
2. Выход за пределы лимитов по позиции: цель отклоняется.

Ошибки:
1. Несуществующий сустав.


Задатчик `AnimationStoredJointTrajectory` (исполнение сохраненных траекторий `FollowJointTrajectoryGoal`)
----------------------------------------------------------------

Считывает набор траекторий из файлов в заданном каталоге. При получении сообщения с текстовым идентификатором нужной траектории 
исполняет ее. Предназначен для проигрывания именованных анимаций.

### Входные порты


1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.
1. `joints_sorted` (`JointState`) --- состояние робота в угловой СК (желаемая или реальная по датчикам), сообщение отсортировано по кинематическим цепочкам.

### Выходные порты

1. `ref_joints` (`JointState`) --- задающее воздействие в угловой системе координат.
1. `ref_support` (`SupportState`) --- ожидаемое распределение веса, всегда ноль для управляемой конечности.

### Параметры

1. `string trajectoris_path` --- каталог с фалами траекторий (каталоги?).

Возможны параметры настройки системы сопряжения траекторий.

### Операции

1. Предоставляет: действие `TextAction` --- выбор траектории по имени.
2. Требует: сервис `robot_model`.

### Семантика исполнения

**Конфигурация**: загрузка и кэширование всех траекторий из файлов с последующим выбором по имени.

**Получение нового задания**: то же, что в случае `AnimationJointTrajectory`, однако строить сплайн уже не надо: он есть в кэше.

**Исполнение**: совпадает с `AnimationJointTrajectory`.

### Детали реализации

Использует тот же базовый класс и структуры хранения траектории, что `AnimationJointTrajectory`

### Ошибки и исключения

Предупреждения:
2. Выход за пределы лимитов по позиции: цель отклоняется.
1. Файл не читается.

Ошибки:
1. Несуществующая траектория.
1. Несуществующий сустав.



Сохранение движения: нода `JointTrajectoryEditor`
-----------------------------------------------

Предоставляет пользовательский интерфейс для создания траекторий по контрольным точкам. 

### Подписан на топики

1. `joints_real` (`JointState`) --- реальная поза робота по датчикам.
1. `joints_virtual` (`JointState`) --- поза виртуального робота.

### Публикует топики

1. `joints_virtual_set` (`JointState`) --- команда мгновенного изменения позы виртуального робота.
1. `joints_marker_set` (`JointState`) --- выбор строки в списке крнтрольных точек.

### Сервисы

1. Требует: `deployer_eval` (`string -> bool`) --- заставляет Deployer OROCOS исполнить заданный скрипт через сервис `rosdeployer`.
    Это относительно спорный способ доступа к операциям `HerkulexArray`. В будущем нужен компонент-прокси, т.к. ноды ROS не могут напрямую вызывать операции OROCOS.
    Рассматривать как временное решение до реализации задатчика включения/выключения приводов.
  

### Действия 

1. Требует: `follow_trajectory_virtual` (`FollowJointTrajectoryAction`) --- передать траекторию виртуальному роботу.
1. Требует: `follow_trajectory` (`FollowJointTrajectoryAction`) --- передать траекторию реальному роботу.

### Параметры

1. `herkulex_array` (`string`) --- имя компонента `HerkulexArray` при использовании `rosdeployer`.

### Семантика исполнения

Компонент предоставляет GUI в виде окна со списком или таблицей контрольных точек и рядом кнопок.
Он реагирует на действия пользователя, осуществляя различные действия.

Компонент обрабатывает только подмножество сочленений, имеющих отношение к редактируемой траектории. 
Это множество задается в диалоге (или вкладке) `Trajectory setup...`. 
Если не оговорено другого, то из сообщений должны извлекаться и обрабатываться только они.

Основные элементы окна:

1. **Диалог (вкладка) "Trajectory setup..."** --- доступ к изменению базовых параметров траектории `FollowJointTrajectoryGoal`. 
    Текстовые поля для `name` (имя файла), `goal_tolerance`.
    Наиболее гибкое представление для `joints_names`, `path_tolerance`, `goal_tolerance` --- таблица. 
    Желательно предусмотреть возможность назначения лимита для всех звеньев сразу. В перспективе можно сделать "выключение" звеньев, 
    когда они остаются в таблице, но траектория им не посылается, отображения текущей позы.

    Алтернативный упрощенный вариант --- через текстовые поля, ввод через пробел.

    В списке не может быть неизвестных звеньев.

2. **Список/таблица контрольных точек**: удаление точки, редактирование времени, отображение и редактирования списка значений углов (не особо надо), 
    пометка начальной и конечной точки, флаг "выключения" строки (становится серой, не участвует в формировании траектории).

    При выделении пункта посылается сообщение `joints_marker_set`. 

    Должны быть обеспечены средства контроля целостности: список отсортирован по времени, маркер начала раньше конца и т.п. 
    В перспективе можно добавить отметки, какой точке соответсвует реальная и моделируемая в пределах `path_tolerance`.


3. **"Reverse direction"** --- меняет местами начальную точку и конечную (при наличии конпки "Execute real backward" не нужно).

1. **"Speed scale"** (слайдер), кнопка **"Apply scale"** --- первый устанавливает модификатор масштаба времени при исполнении (не меняет таблицу), 
    вторая применяет этот модификатор к таблице.

4. **"Add pose from vurtual"** --- добавляет в список точек позу `joints_marker`.

5. **"Add pose from real"** --- добавляет в список точек позу `joints_real`.

1. **"Set virtual pose"** --- устанавливает позу виртуального робота через `joints_virtual_set` в соответсвие с выбранной строкой списка.

1. **"Turn all servos on/off"** --- отключает/включает приводы робота.

1. **"Turn all trajectory servos on/off"** --- отключает/включает приводы, входящие в траекторию.

1. **"Execute virtual"** --- передает траекторию на исполнение задатчику виртуального робота. Результат действия `actionlib` отображается рядом с кнопкой.
    Траектория формируется по текущему содержимому списка от "начальной точки" к "конечной". Это позволяет удобно отлаживать кусок траектории.

1. **"Execute real"** --- передает траекторию на исполнение задатчику реального робота аналогично пункту выше. Результат по получению отображается рядом с кнопкой.

1. **"Execute real backward"** --- то же, но траектория исполняется в обратном направлении. Удобно для возврата робота в исходную позу.

1. **"Save trajectory...", "Load trajectory..."** --- загрузка и сохранение траектории. Всегда сохраняется полное содержимое таблицы, от начала до конца, 
    масшатб скорости исполнеения игнорируется. Т.к. используются редко, то логично перенести в "Tarjectory Setup..." или меню.

### Детали реализации

Для представления списка следует использовать отдельный класс.
Непосредственно `FollowJointTrajectoryGoal` формируется по экземпляру этого класса по соответствующим командам. Он же занимается разбором `JointState`
Следует сразу предусмотреть возможность хранения и отображения `TextCommand` и дальнейшей замены `FollowJointTrajectoryGoal` на `FollowJointTrajectoryWithActionsGoal`

**Эскиз класса списка поз**: `WaypointsList`

*Поля*:
1. Список управляемых суставов.
2. Значения о допусков.
3. Список (`vector` или `list`) структур контрольных точек, хранящих углы, время, маркеры и признак активности точки.

*Методы*:
1. Конструктор.
2. Назначение допусков.
3. Добавление точки (аргумент --- полный `JointState` из которого выбираются нужные, если отсутсвуют, то ошибка).
4. Удаление точки.
5. Операции с маркерами, отключение точек (нужно видеть весь список, чтобы контролировать целостность, напрмер, нельзя отключить контрольную точку, помеченную начальной).
6. Применение масштаба времени.
7. Создание `FollowJointTrajectoryGoal` c заданным масштабом (задавать только позиции).

Спорен вопрос о метсте хранения допусков. Но без них не получится создавать `FollowJointTrajectoryGoal` одной операцией.

Для работы с действиями использовать `SimpleActionClient`, по одному на каждый задатчик.

Отдельную проблему представлет выбор стратегии взаимодействия вкладки **"Setup"** и списка звеньев. 
Не ясно, что должно происходить с элементами списка в этом случае, т.к. они снабжаются дополнительной информацией.
Возможны варианты:
1. **Setup** доступна только при пустом списке. Гарантирует, что новые звенья без известных позиций не могут быть добавделены. Самая простая реализация.
1. При изменении списка звеньев в **Setup** звенья удаляются/добавляются в траекторию. Новые звенья добавлются в нулевой позиуией во все точки (или позиция запрашивается у пользователя в диалоге, одна на все точки). 
    Более сложная реализация, поведение может быть неожиданным для пользоваетля.
2. Точки траектории в списке хранят поную позу, поэтому нет проблемы с добавлением/удалением звеньев. В данном варианте возникают сложности с процедурой **Load**, т.к. файл с `FollowJointTrajectoryGoal` 
    не хранит лишную информацию.

Для первичной реализации предлагается стратегия 1 с последующим переходом на 2.

Вероятно, удобнее всего писать на python. От интерфейса не требуется реальное время.
