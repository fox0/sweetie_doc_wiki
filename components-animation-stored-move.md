Задатчик: повторение сохраненного движения `AnimationStoredMove`
===============================================================

Сначала проводится "обучение" траектории, путем сохранения `JointState` в для заданных контрольных точек (поза и время).
Контрольные точки могут быть указаны путем перемещения конечности робота, либо средствами `rviz`, время указывается вручную.
Такой способ задания выбран, так как трудно вручную провести конечность сразу по заданной траектории в реальном времени.

Затем задатчик загружает набор точек, сглаживает траекторию сплайном в угловой системе координат и проигрывает ее. 

Хранение траектории
-------------------

Траектория должна снабжаться метаинформацией:
1. Имя движения.
1. Задействованные ресурсы.
2. Диапазон допустимых отклонений начальной позы.
3. Мультипликатор времени, указывающий насколько быстро траектория проигрывается.

Сама траектория всключает:
1. Метки времени (не обязательно равномерно распределенные).
2. Структуры `JointState`.

Сообщения можно сохранять используя разныем методы: `boost::serialize` (типы OROCOS допускают сериализацию, реализация очевидна), средства сериализации ROS.

Вариантов хранения несколько:

1. Хранить траекторию и метаинформацию вместе. Все данные сериализутся в один файл.
    
    *Неудобство*: затруднено ручное редактирование метаинформации.

2. Разделять метаинформацию и траекторию: хранить метаинформацию в `*.cpf`, траекторию в бинарном файле посредством сериализации.

	*Неудобство*: два файла, использование XML, необходимость созадавть `*.cpf` вручную или иным способом.


Задатчик: повторение сохраненного движения `AnimationStoredMove`
----------------------------------------------------------------

Сохранение движения: компонент `AnimationStore`
-----------------------------------------------


