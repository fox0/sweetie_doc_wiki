Подсистема исполнения сохраненных движений
===========================================

Подсистема включает в себя интерактивные средства построения траекторий в угловой СК путем задания последовательности конрольных точек 
и задатчики системы управления движением, исполняющие эти траектории.

Эти возмжности в осоновном необходимы для создания анимаций. Сначала робот "обучается" движению путем помещения в ключевые позы,
а затем это движение проигрывается задатчиком по текстовому идентификатору. 

Требования
----------

1. Проигрывание траекторий заданных в угловой СК (на уровне `JointState`) в разных вариантах:
    * траектория передается в виде сообщения,
    * траектория передается в виде сообщения с дополнительной информацией о действиях, задаваемых текстовыми идентификаторам (смена анимации глаз, проигрывание звуков),
    * траектория хранится в файле (с доп. действиями или без) исполняется по сообщению с указанием ее идентификатора.

2. Частичная или полная интеграция с [MoveIt!](http://moveit.ros.org): исполнение траекторий, сохранение их.
    В перспективе использование ее средств для проверки столкновений.

3. Интерактивные средства создания траекторий, путем указания контрольных точек в угловой СК и времени исполнения. 
    Траектории могут снабжаться информацией о дополнительных действиях. 
    * Возможность работы только с моделью робота (траектория исполняется в `rviz`, контрольные точки задаются средствами ROS).
    * Возможность работы с роботом (траектория исполняется роботом, контрольные точки задаются позой).
    * Любое сочетание этих режимов.
    * Формирование файлов с сохраненными траекториями для последующего исполнения задатчиками.

Архитектура подсистемы
-----------------------

Для управления движением используются действия `actionlib`.
Это наиболее полно соответствует конечному характеру траектории, позволяет контролировать и прерывать ее исполнение.

### Базовый вариант (без поддержки текстовых действий)

Базовый вариант системы включают два типа задатчиков:
* `AnimationJointTrajectory` --- исполнение действия `control_msgs::FollowJointTrajectory`. 
* `AnimationStoredJointTrajectory` --- загружает траектории в виде сообщений `control_msgs::FollowJointTrajectoryGoal` из файлов, 
    исполняет нужную по текстовому действию `TextAction`.
Первый задатчик используется в основном для интерактивного построения траектории и интеграци с MoveIt!. Построенные траектории сохраняются в файлы, чтобы потом исполняться
при помощи `AnimationStoredJointTrajectory`.

Оба задатчика поддерживают сопряжение траекторий (за счет [механизма фильтров](library-filters) для `JointState`), отмену исполнения траектории,
переключение на другую траекторию. Набор необходимых ресурсов определяется по списку сочленений при помощи плагина [`RobotModelURDF`](plugin-robotmodel).
Полученная или загруженная траектория приближается сплайнами второго порядка.

На стороне высокого уровня могут функционировать следующие компоненты:
* Подсистема [MoveIt!](http://moveit.ros.org), она способна передавать команды в форме действий `control_msgs::FollowJointTrajectory`.
* Компонент `joint_trajectory_editor`, выполняющий роль GUI для создания траекторий. Его центральный элемент --- список контрольных точек. 
   Он предоставляет пользователю следующие возможности:
   * Редактирование: добавление в список точки (поза в `rviz`, реальная поза), назначение `time_from_start` для точек, редактирование заголовка `FollowJointTrajectory`.
   * Сохранение траектории в файл.
   * Команды: послать траекторию на исполнение, отключить/включить приводы, отключить/включит исполнение траектории приводами робота.
     
Ниже приведена структурная схема системы, используемой для интерактивного построения траекторий: 

![arch-joint-trajectory.png](arch-joint-trajectory.png)

Она включает с себя 3 подсистемы:  реальный робот (`motion`), виртуальный робот (`motion_virtual`), средства редактирования траектории (`trajectory_editor`).
`joint_trajectory_editor` занимает центральное место в схеме. Он может передавать траекторию на исполнение виртуальному или реальному роботу,
устанавливать позу виртуального (`joints_virtual_set`), включать\выключать приводы реального робота (`setAllServosTorque`, `setRegisterRAM`), что позволяет менять позу вручную, добавлять в свой список контрольных точек новые с топиков `joints_marker` и `joints_real`.

При использовании траекторий с информацией о дополнительных командах меняется тип действий `follow_trajectory_action`.

Отдельный вопрос представляет задание позиции суставов, не управляемых редактируемой траекторией. Для реального робота это придется делать 
вручную, отключив приводы. Для виртуального надо предусмотреть проброску неиспользуемых в траектории сочленений в `joints_virtual_set`.

Хранение траекторий предлагается осуществлять за счет встроенных средств [cериализации ROS](http://wiki.ros.org/roscpp/Overview/MessagesSerializationAndAdaptingTypes). 
Альтернативой могут выступать средства сериализации OROCOS ([`boost::serialization`](http://www.boost.org/doc/libs/1_63_0/libs/serialization/doc/tutorial.html)).
В одном файле --- одна траектория, имя файла выступает в качестве идентификатора движения. 
Недостатком такого подхода является сложность с добавлением описания к траектории.

### Типы данных

#### Траектория в угловой системе координат

Используются сообщения из [`control_msgs`](http://docs.ros.org/api/control_msgs/html/index-msg.html)

**Семантика**: 
* `control_msg::FollowJointTrajectoryGoal` --- траектория в угловой СК с информацией о требованиях к ее исполнению.
* `control_msg::FollowJointTrajectory` --- действие `actionlib` по исполнению траектории в угловой СК.

**Прагматика**: эти типы сообщений и действий используются `MoveIt!.

Сообщение `FollowJointTrajectoryGoal`:

    trajectory_msgs/JointTrajectory trajectory  # непосредственно траектория, массив JointState, снабженный метками времени
    JointTolerance[] path_tolerance             # допустимая ошибка для каждого сочленения при исполнении
    JointTolerance[] goal_tolerance             # допустимая ошибка для каждого сочленения в конце траектории
    duration goal_time_tolerance                # допустимое отклонение по времени

Поле `path_tolerance` используются для проверки начальных условий исполнения траектории и последующего  контроля движения. 
`goal_tolerance` проверяется по окончанию движения. 

#### Текстовое действие

**Семантика**: любое действие, задаваемое текстовым идентификатором. Такие действия могут использованы для выбора траектории среди сохраненных, выбора анимации изображений глаз.

**Замечание**: надо поискать в ROS аналоги.

**Замечание**: возможно расширение за счет введения параметров в виде пар строка и число или строка и строка.


**`TextCommand`** --- базовая текстовая команда.
 
    # Command text identificator.
    #
    #  * type --- type of action.
    #  * command --- text action identificator.
    string type
    string command


**`TextCommandStamped`** --- текстовая команда, привязанная ко времени. 

    TextActionGoal command
    duration time_from_start



**`TextAction`** --- текстовое действие `actionlib`

 
    TextCommand command
    ---
    ---
    int32 result
    string result_string
    int32 SUCCESSFUL = 0
    int32 UNKNOWN_COMMAND = -1

*Замечание*: наилучший способ представления `Feedback` и `Result` не ясен из-за разнородности возможных команд.

#### Траектория в угловой СК с текстовыми действиями

**Семантика**: задает движение робота с сопутствующими действиями (смены анимаций, режимов работы и т.п.)

**`FollowJointTrajectoryWithActions`*  --- действие `actionlib` для траектории с информацией о дополнительных действиях. 

    FollowJointTrajectoryGoal trajectory
    TextCommandStamped[] text_commands
    ---
    FollowJointTrajectoryResult trajectory
    ---
    FollowJointTrajectoryFeedback trajectory


**`FollowJointTrajectoryWithActionsGoal`*  --- траектория в угловой СК и информацией о дополнительных действиях.



Задатчик `AnimationJointTrajectory` (исполнение действия `FollowJointTrajectory`)
----------------------------------------------------------------

Задатчик исполняет траекторию переданную в `FollowJointTrajectoryGoal`. 
Варианты использования:
* интеграции с MoveIt!, 
* исполнения отдельных "безымянных" траекторий,
* как часть ситемы интерактивного построения траекторий движения (анимация).

### Входные порты

Синхронизация

1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.

Текущее состояние робота

1. `joints_sorted` (`JointState`) --- состояние робота в угловой СК (желаемая или реальная по датчикам), сообщение отсортировано по кинематическим цепочкам.

### Выходные порты

Поза робота (gait)

1. `ref_joints` (`JointState`) --- задающее воздействие в угловой системе координат.
1. `ref_support` (`SupportState`) --- ожидаемое распределение веса, всегда ноль для управляемой конечности.

### Параметры

Возможны параметры настройки системы сопряжения траекторий.

### Операции

1. Предоставляет: действие `control_msg::FollowJointTrajectory`.
2. Требует: сервис `robot_model`.

### Семантика исполнения

**Получение нового задания**: 
* проверка условий запуска (поза робота в пределах лимитов из задания), 
* прерывание старого задания,
* построение сплайна по полученной траектории, 
* используя сервис `robot_model` определяет набор нужных ресурсов, запрашивает ресурсы.

**Исполнение**: 
* проверяет, что не нарушены лимиты отклонения от траектории, 
* используя кешированный сплайн и прошедшее время, определяет желаемую позицию, 

### Детали реализации

Т.к. компоненты задатчиков будут иметь общий код, то рекомендуется вынести его в родительский класс `AnimationJointTrajectoryBase`, 
общий для всех задатчиков.

После получения задания траекторию и ее лимиты лучше кэшировать в удобную структуру. В частности, может понадобится переупорядочивание звеньев, в соответствии с принятым порядком.

Для интерполяции предлагается использовать [`alglib`](http://www.alglib.net/interpolation/spline3.php) ([`tinyspline`](https://github.com/retuxx/tinyspline) 
не подходит, т.к. не обеспечивает неравномерные временные интервалы. **Проверить!**).

Лучше использовать алгоритмы [сопряжения  траекторий](library-filters) второго порядка. Реализация должна подразумевать возможность 
легкой замены алгоритма сопряжения, выбора его через параметры, передача параметров ему. Открыт вопрос использования сервиса OROCOS.


### Ошибки и исключения

Предупреждения:
2. Выход за пределы лимитов по позиции: цель отклоняется.

Ошибки:
1. Несуществующий сустав.


Задатчик `AnimationStoredJointTrajectory` (исполнение сохраненных траекторий `FollowJointTrajectoryGoal`)
----------------------------------------------------------------

Считывает набор траекторий из файлов в заданном каталоге. При получении сообщения с текстовым идентификатором нужной траектории 
исполняет ее. Предназначен для проигрывания именованных анимаций.

### Входные порты


1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.
1. `joints_sorted` (`JointState`) --- состояние робота в угловой СК (желаемая или реальная по датчикам), сообщение отсортировано по кинематическим цепочкам.

### Выходные порты

1. `ref_joints` (`JointState`) --- задающее воздействие в угловой системе координат.
1. `ref_support` (`SupportState`) --- ожидаемое распределение веса, всегда ноль для управляемой конечности.

### Параметры

1. `string trajectoris_path` --- каталог с фалами траекторий (каталоги?).

Возможны параметры настройки системы сопряжения траекторий.

### Операции

1. Предоставляет: действие `TextAction` --- выбор траектории по имени.
2. Требует: сервис `robot_model`.

### Семантика исполнения

**Конфигурация**: загрузка и кэширование всех траекторий из файлов с последующим выбором по имени.

**Получение нового задания**: то же, что в случае `AnimationJointTrajectory`, однако строить сплайн уже не надо: он есть в кэше.

**Исполнение**: совпадает с `AnimationJointTrajectory`.

### Детали реализации

Использует тот же базовый класс и структуры хранения траектории, что `AnimationJointTrajectory`

### Ошибки и исключения

Предупреждения:
2. Выход за пределы лимитов по позиции: цель отклоняется.
1. Файл не читается.

Ошибки:
1. Несуществующая траектория.
1. Несуществующий сустав.



Сохранение движения: нода `JointTrajectoryEditor`
-----------------------------------------------

Предоставляет пользовательский интерфейс для создания траекторий по контрольным точкам. 

### Подписан на топики

1. `joints_real` (`JointState`) --- реальная поза робота по датчикам.
1. `joints_virtual` (`JointState`) --- поза виртуального робота.
1. `joints_marker` (`JointState`) --- поза, задаваемая пользователем.

### Публикует топики

1. `joints_virtual_set` (`JointState`) --- команда мгновенного изменения позы виртуального робота.
1. `joints_marker_set` (`JointState`) --- команда мгновенного изменения позы, отображаемой интерфейсом пользователя.

### Сервисы

1. Требует: `deployer_eval` (`string -> bool`) --- заставляет Deployer OROCOS исполнить заданный скрипт через сервис `rosdeployer`.
 Это относительно спорный способ доступа к операциям `HerkulexArray`. В будущем нужен компонент-прокси, т.к. ноды ROS не могут напрямую вызывать операции OROCOS.

### Действия 

1. Требует: `follow_trajectory_virtual` (`FollowJointTrajectory`) --- передать траекторию виртуальному роботу.
1. Требует: `follow_trajectory` (`FollowJointTrajectory`) --- передать траекторию реальному роботу.

### Параметры

1. `herkulex_array` (`string`) --- имя компонента `HerkulexArray` при использовании `rosdeployer`.

### Семантика исполнения

Компонент предоставляет GUI в виде окна со списком или таблицей контрольных точек и рядом кнопок.
Он реагирует на действия пользователя, осуществляя различные действия.

Компонент обрабатывает только подмножество сочленений, имеющих отношение к редактируемой траектории. 
Это множество задается в диалоге `Trajectory setup...`. 
Если не оговорено другого, то из сообщений должны извлекаться и обрабатываться только они.

Основные элементы окна:

1. **Диалог "Trajectory setup..."** --- доступ к изменению базовых параметров траектории `FollowJointTrajectoryGoal` через текстовые поля, ввод через пробел
(`name`, `joints_names`, `path_tolerance`, `goal_tolerance`, `goal_time_tolerance`).

2. **Список/таблица контрольных точек**: удаление точки, редактирование времени, редактирования списка значений углов (не особо надо), пометка начальная точка и конечная точка.
При выделении пункта посылается сообщение `joints_marker_set`. 

3. **"Reverse direction"** --- меняет местами начальную точку и конечную.

4. **"Add pose from marker"** --- добавляет в список точек позу `joints_marker`.

5. **"Add pose from real"** --- добавляет в список точек позу `joints_real`.

1. **"Set virtual pose"** --- устанавливает позу виртуального робота `joints_virtual_set` из `joints_marker`. Использует полную позу.

1. **"Turn all servos on/off"** --- отключает/включает приводы робота.

1. **"Turn all trajectory servos on/off"** --- отключает/включает приводы, входящие в траекторию.

1. **"Execute virtual"** --- передает траекторию на исполнение задатчику виртуального робота. Результат по получению отображается рядом с кнопкой.
Траектория формируется по текущему содержимому списка от "начальной точки" к "конечной". Это позволяет удобно отлаживать кусок траектории, 
изменять направление.

1. **"Execute real"** --- передает траекторию на исполнение задатчику реального робота аналогично пункту выше. Результат по получению отображается рядом с кнопкой.

1. **"Execute real backward"** --- то же, но траектория исполняется в обратном направлении. Удобно для возврата робота в исходную позу.

1. **"Save trajectory...", "Load trajectory..."** --- загрузка и сохранение траектории.

### Детали реализации

Для представления элементов списка следует использовать отдельный тип. Непосредственно `FollowJointTrajectoryGoal` формируется только по соответствующим командам.
Следует сразу предусмотреть возможность хранения и отображения `TextCommand` и дальнейшей замены `FollowJointTrajectoryGoal` на `FollowJointTrajectoryWithActionsGoal`

Для работы с действиями использовать `SimpleActionClient`, по одному на каждый задатчик.

Вероятно, удобнее всего писать на python. От интерфейса не требуется реальное время.
