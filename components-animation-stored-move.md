Задатчик: повторение сохраненного движения `AnimationStoredMove`
===============================================================

Проводится "обучение" траектории, путем сохранения `JointState` в для заданных контрольных точек (поза и время).
Контрольные точки могут быть указаны путем перемещения конечности робота, либо средствами `rviz`.

Время и прочая метаинформация указывается вручную путем непосредственного редактирования файла траектории.
Такой способ задания выбран, так как трудно вручную провести конечность сразу по заданной траектории в реальном времени.

Затем задатчик загружает набор точек, сглаживает траекторию сплайном в угловой системе координат и проигрывает ее. 

Хранение траектории
-------------------

Траектория должна снабжаться метаинформацией:
1. Имя движения.
1. Задействованные ресурсы.
2. Диапазон допустимых отклонений начальной позы.
3. Мультипликатор времени, указывающий насколько быстро траектория проигрывается.

Сама траектория всключает:
1. Метки времени (не обязательно равномерно распределенные).
2. Структуры `JointState`.
Сообщения можно сохранять используя разныем методы: `boost::serialize` (типы OROCOS допускают сериализацию, реализация очевидна), средства сериализации ROS, 
сторонние библиотеки.

Вариантов хранения несколько:

1. Хранить траекторию и метаинформацию вместе. Все данные сериализутся в один файл.
    
    *Неудобство*: затруднено ручное редактирование метаинформации, если формат файла нечеловекочитабелен.

2. Разделять метаинформацию и траекторию: хранить метаинформацию в `*.cpf`, траекторию в бинарном файле посредством сериализации.

	*Неудобство*: два файла, использование XML, необходимость созадавть `*.cpf` вручную или иным способом.

Предлагается использовать подход с **совместным хранением** метаинформации и траектории с сериализацией в YAML посредством [yaml-cpp](https://github.com/jbeder/yaml-cpp).

С одной стороны это обеспечивает совместное хранение ненастраиваемых данных, а с другой обеспечит возможность ручного редактирования.
Возможно также использование XML, но его чтение затруднено.
Подобный подход примененн в [NimbRO-OP](https://github.com/NimbRo/nimbro-op-ros/tree/master/src/nimbro/motion/motion_player).

### Формат файла

Способ хранения траектории оптимизирован под ручное задание, указывается минимальный набор контрольных точек.

    name: trajectory_name (string)
    description: trajectory_description (string)
    resources: [ resource1, resource2 ] # список ресурсв (string)
    joints: [ joint1, joint2, ... ] # имена задействованных приводов (string)
    delta_minus: [ joint1_mlim, joint2_mlim, ... ] # допустимое отклонение от начальной позы в меньшую сторону (float)
    delta_plus: [ joint1_plim, joint2_plim, ... ] # допустимое отклонение от начальной позы в меньшую сторону (float)
    trajectory: 
		 - time: time # сдвиг времени от предыдущей точки, в первом элементе всегда ноль (c) (float)
		   position: [ j1, j2, ... ] # поза (радианы) (float)
		 - time: time # сдвиг времени от предыдущей точки (c) (float)
		   position: [ j1, j2, ... ] # поза (радианы) (float)

**Замечание**: размеры массивов должны совпадаить, порядок следования звеньев не должен меняться, иначе файл считается некорректным.

**Замечание**: `RobotModel` позволяет определить набор необходимых ресурсов по списку звеньев. Однако для упрощения задатчика 
эти поля предлагаются заполнеными корректно.

Задатчик: повторение сохраненного движения `AnimationStoredMove`
----------------------------------------------------------------

Загружает траектории, сглаживает их сплайном 3-его порядка в угловой системе координат, 
формирует нужную траекторию в угловой СК,

### Входные порты

Синхронизация

1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.

Текущее состояние робота

1. `joints_sorted` (`JointState`) --- состояние робота в угловой СК (желаемая или реальная по датчикам), сообщение отсортирвано по кинематическим цепочкам.

### Выходные порты

Поза робота (gait)

1. `ref_joints` (`JointState`) --- задающее воздействие в угловой системе координат.
1. `ref_support` (`SupportState`) --- ожидаемое распределение веса, всегда ноль для управляемой конечности.

### Параметры


1. `animation_files` (`strings`) --- YAML файлы с траекториями.
1. `filter_period` (`double`) --- период фильтрации при сопряжении траекторий.
1. `period` (`double`) --- период дискретизации, должен совпадать с периодом таймера.

### Операции

1. `setTimeMultipler(string animation, float mul)` --- коэффициент ускорения времени для заданной анимации. 

**Интерфейс `actionlib`**

Цель:

    string animation

Состояние:

    --

Результат:

    bool success
    # string reason

### Семантика исполнения

**Конфигурация** включает загрузку трекорий из файлов, проверку корректности, осуществление интерполяции сплайнами.

**goalCallback** проверяется соответствие текущей позы заданным лимитам (`-mlim <= pos_start - pos_actual <= plim`). 
При удовлетворении условий запуска происходит стандартная последовательность активации: сбрасываются сопрягающие траектории фильтры.
устанвливается новая траектория. Установка новой цели прерывает текущую анимацию.

**Исполение** каждый период дискретизации выдается скорость и позиция определяемая сплайном. Для обеспечивания безударных сопряжений траекторий
применяется фильтр [перехода от заданного сотояния к траектории](library-filters).

### Детали реализации

Аналогично NimbRO-OP предлагается  реализовать класс представляющий траектории `TrajectorySpline`, обеспечивающий:

2. Загрузку YAML (конструктор, проверка корректности)
1. Доступ к траектории и ее метаинформации.
3. Интерполяцию: `interpolate(float t, vector<double>& pos, vector<double>& vel)` (или `JntArray`?)

Для интерполяции предлагается использовать [`alglib`](http://www.alglib.net/interpolation/spline3.php) ([`tinyspline`](https://github.com/retuxx/tinyspline) 
не подходит, т.к. не обеспечивает неравномерные временные интервалы. **Проверить!**).

Класс не поддерживает сохранение в файл. Это функция другого компонета.

Для сопряжения траекторий желателено использовать фильтр второго порядка (вероятно, экспоненциальный переход с ограничением скорости). 
Чтобы избежать выделения памяти при переключении траекторий он должен иметь максимальную необходимую размерность. 

### Ошибки и исключения

Предупреждения:
1. Попытка запустить несуществующую анимацию

Ошибки:
1. Некорректный файл траектории.


Сохранение движения: компонент `AnimationStore`
-----------------------------------------------

Компонент предназанчен для сохранения тректорий. При сохранении формирует шаблон YAML файла с траекторий,
который в дальнейшем требует ручного редактирования: ввести описание, список ресурсов ресурсов и т.п.

Обеспечит режимы:
1. Сохранение `JointState` по внешеней команде как следующую точку траектории.
2. Сохранение входных `JointState` по мере их поступления (интервалы полагаются однаковыми, могут быть потом отредактированы вручную).
2. Сохранение входных `JointState` с заданной периодичностью.

Общая идея функционирования --- сохранение контрольных точек в памяти и запись в YAML по команде.

### Входные порты

1. `joints` (`JointState`) --- сохраняемое сотояние, источником может быть rviz или датчики положения приводов.

### Параметры

1. `joint_list` (`strings`) --- список приводов, положение которых сохраняется (сохранять все, если пуст).
1. `limit` (`float`) --- значение предельных отклонения от начальной позы (радианы), общее для всех приводов.
1. `period` (`float`) --- промежуток времени между точками.

### Операции

1. `void reset()` --- сбросить сохраненную траектоию.
2. `void addPose(float time_delta) --- добавить еще одну точку к сохраненной траектории, `time_delta` --- сдвиг по времени в секундах.
2. `void startDuration(float time) --- осуществлять непрерывный захвать в течении заданого промежутка времени.
2. `bool writeYAML(string file) --- записать результат в файл.


### Семантика исполнения

При добавлениии нового сообщения обеспечичвает проверку корректности: должен быть тот же набор приводов и порядок следования.

### Детали реализации

Первичная переализация не обязана обеспечивать весь функционал. Достаточно захвата позы по внешним событиям (новое сообщение, вызов операции).

В перспективе компонент может быть переписан как плагин `rviz` с возможностью редактирования траектории через GUI и ее проигрывания.
Поэтому рекомендуется реализовывать его как компонент ROS.

При реализации в OROCOS код по непрерывному захвату сообщений можно разместить в `updateHook`, тогда периодичность регулируется `setPeriod`,
а `startDuration` вызывает операцию `start`.


### Варианты использования

Предполагается интерактивное использование: робот помещается вручную в заданную позу, дается команда на сохранение позы. 
Траектория задается несколькими точками и сдвигами времени. 

По завершению задания траектории результат сохраняется как YAML. Однако полученный файл нуждается в ручном редактировании:
требуется указать имя, описание, список ресурсов, возможно, подредактировать лимиты.

