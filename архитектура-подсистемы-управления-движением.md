Архитектура подсистемы управления движением
===========================================

Сюда попадают все подвиджные элементы робота (ноги, голова, хвост) и имитация движения (глаза).

Общие требования к архитектуре
------------------------------

2. Поддержка переключения между походками и анимациями.
1. Индивидуальные модули обратной кинематики для походки, предоставление сервиса обратной кинематики.
3. Походки могут работать в декартовой и угловой СК.
4. Расширяемость (добавление новых модулей).
5. Возможность интерации с остальными средствами ROS (tf, rqt, rviz, diagnostic).

Общая схема
-----------
![arch-schema-7.svg](/uploads/5680097631a8ef047b28999034c3f63f/arch-schema-7.svg)

Принципиально можно выделить следующие подсистемы:

1. Походки/анимации и механизм переключения между ними (`gait_*`, `animation_*`).
2. Агрегация и публикация желаемого состяния робота (`*_agregator`).
3. Расчет управления для приводов (`servo_inv`, `dynamics_inv`).
4. Взаимодействие с аппаратной частью (`herkulex_*`, `*_driver`).
5. Обработка и публикация показания датчиков (`odometry`, `kinematics_dk`).

Основные архитектурные решения
----------------------------------------------

Стрелки изображают потоки данных, они же играют роль переменных состояния модели.

Выбрана схема с "толстыми"  сообщениями. Т.е. по возможности у компонента один выход, содержащий в одном сообщении весь результат работы.
Сообщения содержат позицию и скорость, ускорение определяется дифференцированием.

Кинематические цепоки поименованы и являются разделяемыми ресурсами. Система переключения занимается их выделением по требованию и обеспечивает только отсутсвие конфликтов. 

В декартовой СК поза передается для каждой кинематической цепочки в мообщении `CartesianState`.  В угловой СК разделение на цепочки отсутсвует (сообщение `JointState`), поэтому `agregator_gait` может не обладать знаниями о структуре робота.

Модули `agegator_*` исполняют только одну функцию: формирование полного вектора состояния робота. Полный вектор необходим для визуализации и расчетов по динамическим моделям. Также он гарантирует обновление задающего воздействия для приводов на каждом цикле.

Вычисления выхода компонента проводятся по внешнему синхронизующему сигналу от компонента-таймера (`ON_TIMER`) , либо по обновлению входов (`ON_UPDATE`). Такая схема позволяет достичь синхронизации вычислений с выходом.

Сигнал `f` выделен отдельно по следующим причинам: не может быть включен в `JointState`, не все походк обязаны его генерировать, он нужен только при расчетах с учетом динамики, непонятно, как обрабатывать его в модулях кинематики.

Обсуждение
----------------

Данная схема --- компромисное решение. Во многом оно направлено на упрощение логики взаимодействия компонент.

Ниже перечислены основные проблемы:

1. Отсутсвие привязки привода к конечности в `JointState` может создать неудобства при расчете прямой кинематики и динамики. 
В угловой СК киематическая цепочка не управляется как целое. 

2. Отделение `f` в отдельное сообщение содает проблемы синхронизации. Ввиду медленного изменения величины предлагается не проводить перерасчеты при ее обновлении.

3. Избыточные вычисления: при обновлении любого подмножества вектора состояния требуется перерасчет всей прямой киематики, динамики и моделей приводов. Избавится от этого нельзя, если не ждать в `agregator_gait` выполнения всех задатчиков. Но тогда надо совмещать в агрегаторе еще функции распределения ресурсов (агрегатор должен знать, от кого ждать сообщений) и уменьшается надежность (один из задатчиков опаздывает/отказал). Также есть вариант с активацией его по таймеру. При написании gait и animation следует высылать результаты одним большим сообщением.

4. Начальные условия для агрегатора. Вероятно, после инициализации на входной порт агрегатора надо один раз подать полное состояние робота по датчикам. Лучший кандидат на исполнение такого действия --- опреация в `herkulex_array`.

5. Относительно примитивный алгоритм распределения ресурсов рассматривается отдельно.

Использование ROS и OROCOS
--------------------------

Сема рассчитана на реализацию в OROCOS, поэтому ориентирована на соответвующую семантику 
портов. Порт является аналогом разделяемой переменной, может быть прочитан в любой момент времени.
Отсутсвует прямой аналог топика ROS, что затрудняет организацию соединений "многие к многим".
Это одна из причин введнеия компонентов-агрегаторов.

Однако управление хвостом, ушами и глазами связано с остальной частью системы только через подсистему переключения походок/анимаций. 
Это означает, что она потенциально может быть реализована и средствами ROS, если соответвуюющие модули анимации способны обрабатывать и формировать сообщения `ResourсeRequest`.

Указанная на схеме тесная интеграция может требоваться для помахивания хвостом в такт походки, слежение глазами и головой за объектом,
слитным движениеям-эмоциям (пригнуться к земле, опустить голову, прижать уши).

Некоторые алтернативы
--------------------------------

Надо написать.