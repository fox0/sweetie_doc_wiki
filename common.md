Общие соглашения
================

ROS и OROCOS:
-------------

1. Базовая версия: **ROS indigo** и входящее в нее реализация OROCOS.

2. Используется стандарт **C++03** (соглашение ROS indigo). Компоненты OROCOS работают в одном адресном пространстве,
поэтому версия должна совпадать для все компонент.

В последствии планируется перейти на ROS kinetic, поэтому жесткого ограничения на **C++03** нет. Для включения **C++11** необходимо в CMakeLists.txt файл добавить строку `set (CMAKE_CXX_FLAGS "--std=gnu++11 ${CMAKE_CXX_FLAGS}")`.

ROS: пакеты, типы компонент, имена загруженных компоненты
--------------------------------------------------------

### Пакеты

Один пакет содержит описание нескольких типов компонент со сходным назначением.

**Прагматика** заключается в том, что компоненты со сходным назначением могут
иметь общие части (подсистема кинематических ограничений `gait_*`, загрузка urdf для 
различных версий кинематики). 

Примеры имен пакетов (отдельно нужен полный список):

* `sweetie_bot_msgs` --- базовые типы сообщений.

* `sweetie_bot_motion_switch` --- компонент `motion_switch`, базовый класс задатчика (статическая библиотека).

* `sweetie_bot_agregator` --- агрегаторы.

* `sweetie_bot_kine_dyn` --- компоненты кинематики, динамики, классы работы с urdf (urdf дальнейшем могут быть выделены в отдельный пакет).

* `sweetie_bot_gait_*` --- походки.

* `sweetie_bot_anim_*` --- анимация.

* `sweetie_bot_servo_inv` --- обращение сервоприводов.

* `sweetie_bot_hw_herkulex` --- управление приводами Herkulex, специфичное для sweetie.

* `sweetie_bot_hw_servo` --- управление сервомашинками.


### Типы компонент

Тип компонента для OROCOS --- имя класса-наследника `TaskContext`. 
Предлагается использовать пространство имен, соответствующие именам пакета без префикса `sweetie_bot_*`:

    gait::WaveGait
    gait::TrotGait
    animation::Greeting
    animation_ext::VeryGrownUp
    kine_dyn::KinematicsKDL

Тип компонента для ROS --- имя ноды в пакете.
Роль пространства имен в данном случае уже играет сам пакет (`rosrun <package> <node>`

### Имена загруженных компонент

При загрузке компонента в память ему назначается имя.

1. Использование пространств имен ROS для разделения разных подсистем.

2. В рамках одной подсистемы (подсистемы движения) предлагается использовать префиксы. 
<!--- Имена уникальных компонент (в подсистеме может быть только один компонент такого типа, например, `agregator_gait`, `servo_inv`) 
по возможности должны быть стандартными. 
Это позволяет не менять скрипты развертывания.
ИСКЛЮЧЕНО: разные версии компонент - разные параметры - разные скрипты.
--->

Примеры имен:

    gait_wave_gait --- походка,
    gait_trot_gait --- еще одна походка,
    anim_greeting --- анимация,
    kinematics_inv --- базовая реализация кинематики,
    kinematics_inv_safe_zone --- решение задачи кинематики ограничена некой безопасной зоной, гарантированно исключающей самопересечения,
    servo_inv_trapz --- обращения трапециевидного профиля,
    agregator_gait --- базовая реализация агрегатора.
    

### Имена портов OROCOS

Для повышения читабельности кода развертывания предлагается придерживаться следующих соглашений:

1. Сначала ставится префикс, определяющий направление данных `in_` (входной порт), `out_` (выходной порт).
2. Вторая часть имени порта определяется передавемым типом данных и назначением (если оно не ясно из названия компонента).
3. Если входной порт предполагает каки-то дополнительные ограничения на  структуру составных сообщений,
     указывается постфикс:
     * `_fixed` --- порядок и соcтав элементов не должен меняться при нормальной работе компонена.
     * `_sorted` ---  порядок и состав элементов жестко специфицирован дополнительными требованиями.
     Опционально постфикс может присутствовать и в выходных портах, если такое требование *всегда* гарантирется.

Пункт 3 нужен, чтобы упростить работу компонентов с сообщениями типа `JointState`, и предполагает,
что принимающий компонент не обязан проверять порядок и состав имен приводов каждый цикл управления.

Таким образом, наиболее важная информация in/out в начале (и всегда знаешь, где её найти), дальше идёт основная информация произвольной длины, а в конце уточняющая, тоже сколь угодно длинная. Неизменная информация (in/out), всегда имеющаяся у порта, будет в фиксированном месте, а сразу за ней фактически нужный тип сообщения. Такая схема также удобна для использования автозаполнения в редакторах, т.к. сначала следует информация, которая наиболее общая и часто встречающаяся,  потом тип данных и в конце уточняющая категория, которая далеко не всегда есть и нужна.

Примеры:

    out_joints
    in_joints_sorted
    in_goals_fixed

### Имена топиков ROS

Аналогичная схема, что у OROCOS, на назначение указывается всегда, а постфиксы `_in`и `_out` не требуются

     joints_reference
     joints_measured
     statistics_herkulex

Содержимое пакета
-----------------------------

Рекомендуется снабжать пакет:
1. Файлом README (лучше на английском).
2. Тестовым скриптом для демонстрации/проверки роботоспсобности. Иногда из этого скрипта можно отдельно выделить кусок, 
отвечающий за развертку компонента.

ROS: специфика написания кода
--------------------------------------------------------

Рекомендации.

1. Писать с классами или без?

OROCOS: специфика написания кода
--------------------------------------------------------

При написании кода OROCOS следует помнить несколько вещей:

1. Следует избегать прямых или косвенных вызовов `new` в `updateHook`
    1. Создавать временные переменные `updateHook()` как члены класса. Так, например,  в паре с портом обычно имеет смысл сразу же заводить переменную для хранения его сообщения.
    2. Рекомендуется использовать `setDataSample` (при конфигурации) и `getDataSample`(при запуске), но это не всегда возможно.
    3. Активно использовать передачу сложных типов по ссылке.

2. Помнить, что `updateHook()` вызывается по любому события (включая операции и получение результата операции), 
    при работе с `EventPort` надо явно проверить, пришли ли на него новые данные.

3. OROCOS предоставляет средства работы с нитями, использование их предпочтительней системных:
    * `Activity` --- новая нить,
    * `Timer` --- таймер,
    * `Mutex`, `Semaphore`, `Conditional` --- синхронизация процессов,
    * `BufferLockFree`, `DataObject` --- локальные потокобезопасные средства обмена данных.

4. Документация интерфейса компонент.
    1. Все элементы внешнего интерфейса (порты, операции, параметры, сервисы) должны документироваться.
    2. Не забывайте документировать агрументы операций. 
    3. Сообщение должно быть информативным "Output JointState port" --- плохо, т.к. вся эта информация уже есть (тип, направление отображаются ls). 
         Гораздо лучше "Publishes reference pose for robot legs.", которое сразу указывает, что имеем дело с выходным портом походки.

Сторонние библиотеки
--------------------

Какие средства предпочтительней?


1. STL, какая версия.
2. boost?
3. OpenCV?

Стиль программирования
----------------------

0. Предлагается придерживаться [соглашений стиля ROS](http://wiki.ros.org/CppStyleGuide). (Я хочу делать отступ табуляцией...)

1. Стандартная реализация класса C++ подразумевает использование пары файлов. 
В некоторых случаях несколько тесно связанных классов можно разместить в одном файле.




