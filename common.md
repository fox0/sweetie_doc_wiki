Общие соглашения
================

ROS и OROCSO:
-------------

1. Базовая версия: **ROS indigo** и входящее в нее реализация OROCOS.

1. Используется стандарт **C++03** (соглашение ROS indigo). Компоненты OROCOS работают в одном адресном пространстве,
поэтому версия должна совпадать для все компонент.


ROS: пакеты, типы компонент, имена загруженных компоненты
--------------------------------------------------------

### Пакеты

Один пакет содерит описанеи нескольких типов компонент со сходным назначением.

**Прагматика** заключается в том, что компоненты со сходным назначением могут
иметь общие части (подсистема кинематических ограничений `gait_*`, загрузка urdf для 
различных версий кинематики). 

Примеры имен пакетов (отдельно нужен полный список):

* `sweetie_bot_msgs` --- базовые типы сообщений.

* `sweetie_bot_motion_switch` --- копонент `motion_switch`, базовый класс задатчика (статическая библиотека).

* `sweetie_bot_agregtor` --- агрегаторы.

* `sweetie_bot_kine_dyn` --- компоненты кинематики, динамики, классы работы с urdf (urdf дальнейшем могут быть выделены в отдельный пакет).

* `sweetie_bot_gait_*` --- походки.

* `sweetie_bot_anim_*` --- анимация.

* `sweetie_bot_servo_inv` --- обращение сервоприводов.

* `sweetie_bot_hw_herkulex` --- управление приводами Herkulex, специфичное для sweetie.

* `sweetie_bot_hw_servo` --- управление сервомашинками.


### Типы компонент

Тип компонента для OROCOS --- имя класса-наследника `TaskContext`. 
Предлагается использовать пространтва имен, соответсвующие именем пакета без префикса `sweetie_bot_*`:

    gait::WaveGait
    gait::TrotGait
    animation::Greeting
    animation_ext::VeryGrownUp
    kine_dyn::KinematicsKDL

Тип компонента для ROS --- имя ноды в пакете.
Роль пространства имен в данном случае уже играет сам пакет (`rosrun <package> <node>`

### Имена загруженных компонент

При загрузке компонента в память ему назначается имя.

1. Использование пространств имен ROS для разделения разных подсистем.

2. В рамках одной подсистемы (подсистемы движения) предлагается использовать префиксы. 
<!--- Имена уникальных компонент (в подсистеме может быть только один компонент такого типа, например, `agregator_gait`, `servo_inv`) 
по возможноси должны быть стандартными. 
Это позволяет не менять скрипты развертывания.
ИСКЛЮЧЕНО: разные версии компоенент - разные параметры - разные скрипты.
--->

Примеры имен:

    gait_wave_gait --- походка,
    gait_trot_gait --- еще одна походка,
    anim_greeting --- анимация,
    kinematics_inv --- базовая реализация кинематики,
    kinematics_inv_safe_zone --- решение задачи кинематики ограничена некой безопасной зоной, гарантированно исключающей самопересечения,
    servo_inv_trapz --- обращения трапецивидного профиля,
    agregator_gait --- базовая реализация агрегатора.
    

ROS: специфика написания кода
--------------------------------------------------------

Реккомендации.

1. Писать с классами или без?

OROCOS: специфика написания кода
--------------------------------------------------------

При написании кода OROCOS следует помнить есколько вещей:

1. Следует избегать прямых или косвенных вызовов `new` в `updateHook`
    * Создавать временные переменные `updateHook()` как члены класса.
    * Активно ипользовать передачу сложных типов по ссылке.

2. Помнить, что `updateHook()` вызывается по любому события (включая операции и получение результата операции), 
    при работе с `EventPort` надо явно провереть, пришли ли на него новые данные.Ф

3. OROCOS предоставляет средства работы с нитями, использование их предпочтительней системных:
    * `Activity` --- новая нить,
    * `Timer` --- таймер,
    * `Mutex`, `Semaphore`, `Conditional` --- синхронизация процессов,
    * `BufferLockFree`, `DataObject` --- локальные потокобезопасные средства обмена данных.

Примеры реализации компонент: ссылки

Сторонние библиотеки
--------------------

Какие средства пердпочтительней?


1. STL, какая версия.
2. boost?
3. OpenCV?

Стиль программирования
----------------------

0. Предлагается придерживаться [соглашений стиля ROS](http://wiki.ros.org/CppStyleGuide). (Я хочу делать отступ табуляцией...)

1. Стандартная реализация класса C++ подразумевает использование пары файлов. 
В некоторых случаях несколько тесно связанных классов можно разместить в одном файле.




