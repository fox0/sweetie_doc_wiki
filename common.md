Общие соглашения
================

Отслеживание текущих задач и ошибок
------------------------------------

В настоящий момент используются следующие средства:
* [Trello](https:/b/nP2472ht/sweetie-bot-project#)
    Включает в себя несколько досок: программирование, электроника, конструирование и т.д.
* Баг-трекер репозиториев?

Рекомендуется использовать эти средства для обсуждения особенностей реализации, решений, недочетов. Но основная документация --- wiki. 
Она должна отражать принятый дизайн.

ROS и OROCOS:
-------------

1. Базовая версия ПО: 
    * debain streth,
	* ROS **lunar**
	* OROCOS 2.9.
2. Используется стандарт **C++11**. 

ROS: пакеты, типы компонент, имена загруженных компоненты
--------------------------------------------------------

ROS и OROCOS --- компонентно-ориентированные системы. Основной единицей ПО являются компоненты (исполнимые модули в ROS, разделяемые библиотеки в OROCOS).
Компоненты с средствами развертки, описаниями типов и файлами данных группируют в пакеты.

### Пакеты

Один пакет содержит описание нескольких типов компонент со сходным назначением. 
Сообщения (`msg`, `actionlib`) выделяются в отдельные пакеты, их имя совпадает с именем исходного пакета (если такой имеется) с добавлением постфикса `_msg`.

**Прагматика** заключается в том, что компоненты со сходным назначением могут иметь общие части (подсистема кинематических ограничений `gait_*`, загрузка urdf для 
различных версий кинематики). 


Примеры имен пакетов:

* `sweetie_bot_resource_control_msgs` --- базовые типы сообщений.

* `sweetie_bot_resource_control` --- компонент-арбитр ресурсов, базовые классы задатчика (статическая библиотека).

* `sweetie_bot_agregator` --- агрегатор позы робота

* `sweetie_bot_robot_model` --- плагин, предоставляющей модель робота.

* `sweetie_bot_kinematics` --- компоненты кинематики,

* `sweetie_bot_controller_*` --- различные задатчики движений.

* `sweetie_bot_anim_*` --- анимация.

* `sweetie_bot_servo_inv` --- обращение сервоприводов.

* `sweetie_bot_herkulex` --- управление приводами Herkulex, специфичное для sweetie.


### Пространства имена, иерархия каталогов, именование программных объектов

Используя пространства имен, предлагается выделять относительно независимые подсистемы проекта. 
Спецификатор пространства имен составляет часть имени объекта, что позволяет понять к какой подсистеме относится объект и сократить длину идентификатора.

    sweetie_bot::motion::controller::WaveGait
    sweetie_bot::motion::KinematicsKDL
    sweetie_bot::eyes::DriverSPI

Предлагается следующая **иерархия пространств имен** (дополняться по мере необходимости):

    sweetie_bot --- все, что относится непосредственно к роботу.
     +- logger --- подсистема логгирования (можно вынести в отдельный namespace).
     +- motion (бывшее core) --- подсистема управления движением РВ
     |   +- controller --- походки и анимации, их библиотеки.
     |   +- общие компоненты подсистемы управления движением.
     +- eyes 
     +- hw --- аппаратно-зависимые части, напрямую связанные с роботом.
     |   +- proto2
     |   +- proto3
     |   +- beagle_board 
     +- hmi --- человеко-машинный интерфейс (джойстики, визуализация).
     +- deployment
     ...
    herkulex --- подсистема, которую можно использовать полностью независимо от робота.


**Тип компонента для OROCOS** --- имя класса-наследника `TaskContext`. Для него действуют все описанные выше принципы. 
(Некоторые имена получаются очень длинными).

**Тип компонента для ROS** --- имя ноды в пакете. Роль пространства имен в данном случае уже играет имя пакет пакета (`rosrun <package> <node>`), 
включающее нужные префиксы:

    rosrun sweetie_bot_eyes driver_spi
    rosrun sweetie_bot_hmi_hydra hydra_node 

### Имена репозитариев пакетов, каталогов и файлов


**Имена пакетов** всегда содержат префикс `sweetie_bot`, далее следует характеристика подсистемы, объединяющей несколько компонент. 
Для создания иерархии используется система подкаталогов.  Использование префиксов в именах каталогах --- лишнее, т.к. ROS их не обрабатывает.

     sweetie_bot_resource_control --- арбитр ресурсов
     sweetie_bot_agregator
     sweetie_bot_resource_control_msgs --- сообщения подсистемы арбитра ресурсов
     rtt_sweetie_bot_resource_control_msgs --- typekit сообщений подсистемы арбитра ресурсов (автосгененрированны) 
     sweetie_bot_herkulex_control
     sweetie_bot_herkulex_msgs
     rtt_sweetie_bot_herkulex_msgs
     sweetie_bot_tests --- тесты

Проект разделен на несколько **репозиториев** для возможности использования их по-отдельности. Используется система контроля версий `git`.

    sweetie_bot                         основной репозиторий Свити, включает остальные как подмодули.
    sweetie_bot_rt_control              универсальная часть подсистема управления роботов, написаная на OROCOS.
    sweetie_bot_flexbe_behaviors        FlexBe поведения Свити. 
    sweetie_bot_sounds                  Репозиторий со звуковыми файлами.

**Структура каталогов** основного репозитория:
                
    sweetie_bot             часть системы, специфичная для робота.
     +- rt_control          подсистема управления РВ на OROCOS --- подмодуль git
         +- logger              подситема журналирования РВ (подпроек logger) --- подмодуль git
         +- herkulex            драверы Herkulex UART (herkulex_control, herkulex_msgs)  --- подмодуль git
         +- motion              управление движением (kinematics, agregator, servo_inv и т.п.)
         |  \- controllers      задатчики движения: походки, анимации и т.п.(follow_joint_state, controller_joint_state, gait и т.д.)
         \- config              развертывание OROCOS подсистемы (в проекте).
     +- hardware            интерфейсные модули оборудования 
     +- config              конфигурация, развертывание (robot_description, moveit_config, deploy)
     +- behavior            высокоуровневые компоненты управления поведением робота
     \- hmi                 средства интерфейса (trajectory_editor)

**Имена файлов**:

* Имя файла должно отражать описываемый в нем объект (имя класса, название и назначение библиотеки и т.п.)
* Не следует включать в имя файла префиксы, подобные используемым в именах пакетов. 
    Файлы уже и так изолированы файловой системой и пакетами. Например, следует использовать `herkulex_sched-component.cpp` вместо `sweetie_bot_herkulex_sched-component.cpp`. 
* Рекомендуется использовать постфиксы `-component`, `-service` и т.п. для более точного указания назначения файла. 
    Однако они не должны попадать во внешние интерфейсы пакета (каталог `include`).


### Имена загруженных компонент

При загрузке компонента в память ему назначается имя.

1. Использование пространств имен ROS для разделения разных подсистем.

2. В рамках одной подсистемы (подсистемы движения) предлагается использовать префиксы. 

**Имя загруженного компонента OROCOS**. Т.к. в OROCOS нет пространст имен, имя включает префикс подсистемы.
Имя компонента OROCOS --- это строка, поэтому можно использовать имена вида `herkulex/array` имитирующие пространства 
имен ROS. При загрузке параметров ROS `/` воспринимается, как разделитель, что позволяет иерархически организовать параметры по подсистемам. 
Также устанавливается полное соответствие с категориями журналирования. 

    resource_control/arbiter --- арбитр ресурсов,
    agregator_ref --- агрегатор желаемой позы (выход задатчиков),
    agregator_real --- агрегатор реальной позы,
    herkulex/array --- контроль приводов,
    controller/step_sequence --- еще одна походка (без префикса),
    controller/Joint_trajectory --- анимация,
    kinematics_inv --- базовая реализация кинематики,
    kinematics_inv_safe_zone --- решение задачи кинематики ограничена некой безопасной зоной, гарантированно исключающей самопересечения,
    
В коде развертывания на `lua` используются таблицы вместо префиксов:

    resource_control.arbiter
    controller.gait_wave_gait
    agregator
    herkulex.array

**Имя загруженного компонента ROS** помещаете в пространств имен дублирующую схему для пространств имен выше. 
Непосредственно имена пространств имен выделены заглавными буквами. Топики и параметры помечены префиксами `topic:` и `param:`.

    /
    |- param: robot_description --- URDF model
    |- param: robot_description_semantic --- MoveIt configuration
    |
    |- CONF_FILE --- OROCOS configuration files parameters (.cpf, .log4cpp). 
    |- JOINT_TRAJECTORY --- parameters with joint trajectories.
    |
    |- MOTION --- OROCOS rt control node and configuration. Note that ROS see all OROCOS component as a one node with 'motion' name.
    |    |             This node is lauched on the robot on-board computer.
    |    |
    |    |- ROBOT_MODEL --- OROCOS robot semantic model (kinematics chains, contacts). It is loaded from `kinematic_chains.cpf`.
    |    |
    |    |- CONTROLLER --- motion controllers
    |    |    |- <controller_name> --- controller parameters and its topics.
    |    |    ...
    |    |- HERKULEX --- servo control groups
    |    |    |- LEG12 
    |    |    |    |- array --- provides configuration and debug interface for servos.
    |    |    |    |- driver
    |    |    |    \- sched 
    |    |    ...
    |    |- aggregator_ref --- provides robot reference pose in joint space 
    |    |- kinematics_fwd --- provides robot limbs positons in cartesian space
    |    |- odometry_ref --- base_link odometry
    |    |- dynamics_inv --- robot balace and servo efforts calculation
    |    |- aggregator_real --- provides robot real pose in joint space 
    |    ...
    |
    |- topic: joint_states, tf
    |- topic: control --- high level TextCommands for eyes emotions change and voice control.
    |- topic: move_group, trajectory_execution, pick, place --- MoveIt! topics.
    |
    |- robot_state_publisher --- /tf publication
    |- move_group --- MoveIt! control node, coresponding topics and parameters are loaded in / namespace.
    |- behavior --- FlexBe behavior engine
    |- eye_left, eye_right --- hardware dependent eyes node. They are lauched on the robot on-board computer.
    |
    |- VOICE 
    |   |- voice_node
    |   \- sound_play
    |
    |- FLEXBE --- flexbe operator interface nodes.
    |
    \- HMI --- visualization and opertor interfce
        |- rviz 
        \- pose_markers

#### OROCOS and ROS integration

[`rtt_ros_integration` package](https://github.com/orocos/rtt_ros_integration) allows to map ROS topics on OROCOS ports transparently. Also it gives OROCOS components access to ROS parameter server. 
ROS sees all OROCOS subsystem as one node with name `motion`. OROCOS components advertise their interface in corresponding namespace. For example, `controller/stance` component provides 
actionlib server under `motion/controller/stance` to activate it and listen to the `motion/controller/in_base_ref` topic. The controller get properties from `motion/controller/stance` namespace.

Some parameters of OROCOS components has special meaning: 
 * `period` is set to the main timer period (control cycle duration) which defined in `timer` component configuration.
 * `services` is list of OROCOS subservices to be loaded into component, 
 * `priority` is linux RT priority.

You can access and view ROS nodes, topics and parameters using standard ROS tools. OROCOS components interface can be access via [`rttlua` console](http://www.orocos.org/wiki/orocos/toolchain/luacookbook).
It is started with OROCOS control node. Note that OROCOS component interface is self-documented you can browse `controller/stance` interface using command `= controller.stance`. 


### Категории системы журналирования

Категория системы журналирования конструируется так:

   <полное имя ноды ROS>.<имя загруженного компонента с заменой "/" ".">

(В компоненте жестко прописывается только подсистема, полное имя ноды загружается из `log4cpp.default_root_category` (`getDefaultCategory()` из `logger.hpp`)).

Примеры:

   sweetie_bot.motion.resource_control.arbiter
   sweetie_bot.motion.controller.gait
   sweetie_bot.motion.servo_inv

Для ROS используются штатные средства.

### Имена портов OROCOS

Для повышения читабельности кода развертывания предлагается придерживаться следующих соглашений:

1. Сначала ставится префикс, определяющий направление данных `in_` (входной порт), `out_` (выходной порт).
2. Вторая часть имени порта определяется передаваемым типом данных и назначением (если оно не ясно из названия компонента).
3. Если входной порт предполагает каких-то дополнительные ограничения на  структуру составных сообщений,
     указывается постфикс:
     * `_fixed` --- порядок и состав элементов не должен меняться при нормальной работе компонента.
     * `_sorted` ---  порядок и состав элементов жестко специфицирован дополнительными требованиями.
     Опционально постфикс может присутствовать и в выходных портах, если такое требование *всегда* гарантируется.

Пункт 3 нужен, чтобы упростить работу компонентов с сообщениями типа `JointState`, и предполагает,
что принимающий компонент не обязан проверять порядок и состав имен приводов каждый цикл управления.

Таким образом, наиболее важная информация in/out в начале (и всегда знаешь, где её найти), дальше идёт основная информация произвольной длины, а в конце уточняющая, тоже сколь угодно длинная. Неизменная информация (in/out), всегда имеющаяся у порта, будет в фиксированном месте, а сразу за ней фактически нужный тип сообщения. Такая схема также удобна для использования автозаполнения в редакторах, т.к. сначала следует информация, которая наиболее общая и часто встречающаяся,  потом тип данных и в конце уточняющая категория, которая далеко не всегда есть и нужна.

Примеры:

    out_joints
    in_joints_sorted
    in_goals_fixed

### Имена топиков ROS

Аналогичная схема, что у OROCOS, на назначение указывается всегда, а постфиксы `_in`и `_out` не требуются

     joints_reference
     joints_measured
     statistics_herkulex

Содержимое пакета
-----------------------------

Следуем рекомендациям ROS. Вспомогательные скрипты и файлы параметров размещаются в `scripts`.

Пакет снабжается:
1. Файлом README (лучше на английском).
2. Тестовым скриптом для демонстрации/проверки работоспособности. Иногда из этого скрипта можно отдельно выделить кусок, 
отвечающий за развертку компонента.

Цель прикладываемой документации --- дать четкое понимание, что содержит пакет, для чего предназначен и как проверить его работоспособность. 
Тестовый скрипт также выполняет роль примера использования для последующей интеграции пакета.

Журналирование
--------------------------

Для ROS используются штатные средства `rosout`.

Для OROCOS два варианта:

1. RTT::Logger --- штатное средство, не поддерживает категории, т.е. лог общий для всех. Рекомендуется только использование для вывода сообщений пользователю  и ограниченно для отладочных сообщений, выводимых *незначительное* число раз при отладке компонента.

2. G&P Logger --- часть проекта, поддерживает категории, реальное время, /rosout. Использовать всегда при отладочном выводе, идущем "потоком". Менее удобен для сообщений пользователю. Рекомендуемая опорная инфраструктура: OCL или rosout.

**Принципы журналирования**:

* Категория, используемая для логгирования, отвечает названию подсистемы робота:
       
       sweetie_bot.motion.kinematics_trak_ik
       sweetie_bot.eyes.driver_spi

* Любая нештатная ситуация, характеризующаяся неспособности выполнить запрещенное действие, должна приводить к сообщению в журнале. 
    Уровни сообщений: `CRIT` (работа подсистемы не может быть продолжена), `ERROR` (подсистема осталась работоспособна).

    Примеры: не могу открыть файл, компонент не запущен, привод не отвечает и т.п.


* Ситуация не являющая полноценной ошибкой (желаемое действие в той или иной степени выполнено), но при этом являющаяся подозрительной журналируется, как `WARN`.
    Пример: в процессе работы поменялось число приводов робота.

* Характерные этапы работы подсистемы робота (запуск, успешная конфигурация, остановка, включение походки и т.п.)  отмечаются сообщения уровня `INFO`.

* Отладочные сообщения пропускаются на уровне `DEBUG`. 


ROS: специфика написания кода
--------------------------------------------------------

Рекомендации.

1. Писать с классами или без?

OROCOS: специфика написания кода
--------------------------------------------------------

При написании кода OROCOS следует помнить несколько вещей:

1. Следует избегать прямых или косвенных вызовов `new` в `updateHook`
    1. Создавать временные переменные `updateHook()` как члены класса. Так, например,  в паре с портом обычно имеет смысл сразу же заводить переменную для хранения его сообщения.
    2. Рекомендуется использовать `setDataSample` (при конфигурации) и `getDataSample`(при запуске), но это не всегда возможно.
    3. Активно использовать передачу сложных типов по ссылке.

2. Помнить, что `updateHook()` вызывается по любому события (включая операции и получение результата операции), 
    при работе с `EventPort` надо явно проверить, пришли ли на него новые данные.

3. OROCOS предоставляет средства работы с нитями, использование их предпочтительней системных:
    * `Activity` --- новая нить,
    * `Timer` --- таймер,
    * `Mutex`, `Semaphore`, `Conditional` --- синхронизация процессов,
    * `BufferLockFree`, `DataObject` --- локальные потокобезопасные средства обмена данных.

4. Документация интерфейса компонент.
    1. Все элементы внешнего интерфейса (порты, операции, параметры, сервисы) должны документироваться.
    2. Не забывайте документировать аргументы операций. 
    3. Сообщение должно быть информативным "Output JointState port" --- плохо, т.к. вся эта информация уже есть (тип, направление отображаются ls). 
         Гораздо лучше "Publishes reference pose for robot legs.", которое сразу указывает, что имеем дело с выходным портом походки.

### Внешний интерфейс компонент и сервисов

Следует стараться, чтобы внешний интерфейс сервисов и компонент содержал только элементы, предназначенные для использования из вне (пользователем и другими компонентами). В целях инкапсуляции туда не следует добавлять элементы, которые могут нарушать внутреннее состояние компонента или имеют смысл только в его внутреннем контексте.

Соответственно,  *предпочтительный способ взаимодействия с элементами сервиса, не предназначенными для 
использования компонентами-не-владельцами сервиса --- [приведение к классу интерфейсу при помощи `dynamic_cast`](orocos-services#3-%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%B0-%D0%BF%D0%BB%D0%B0%D0%B3%D0%B8%D0%BD%D0%B0-%D1%82%D0%B5%D0%BA%D1%83%D1%89%D0%B5%D0%B3%D0%BE-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0-%D0%BF%D1%80%D0%B8-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%B8-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B5%D0%BD%D0%BD%D0%B5%D0%B3%D0%BE-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0)*.



Сторонние библиотеки
--------------------

Какие средства предпочтительней?


1. STL, какая версия.
2. boost?
3. OpenCV?

Стиль программирования
----------------------

0. Предлагается придерживаться [соглашений стиля ROS](http://wiki.ros.org/CppStyleGuide). (Я хочу делать отступ табуляцией...)

1. Стандартная реализация класса C++ подразумевает использование пары файлов. 
В некоторых случаях несколько тесно связанных классов можно разместить в одном файле.




