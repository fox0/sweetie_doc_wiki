Задатчики (походки, анимации)
=============================

Компонент формирует задающее воздействии для некоторого набора ресурсов.
Для части ресурсов --- зарегистрированных кинематических цепочек --- выдает желаемую позу в угловой или декартовой системе координат.
Для остальных ресурсов форма задания определяется типом.

Разрешение конфликтов ресурсов обеспечивается [арбитром и клипентским плагином](components-resource-control).

Способ взаимодействия с верхним уровнем не декларируется, но рекомендуется использовать `actionlib`.

Набор интерфейсов сильно зависит от назначения. Далее перечислены большинство возможных способов взаимодействия,
реальный компонент реализует только часть.

### Входные порты

Синхронизация

1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.

Текущее состояние робота

1. `joints_sorted` (`JointState`) --- состояние робота в угловой СК (желаемая или реальная по датчикам), отсортированная по кинематическим цепочкам.
1. `limbs_cartesian` (`CartesianState`) --- состояние робота в декартовой СК (желаемая или реальная по датчикам).
1. `support` (`SupportState`) --- показания датчиков касания.

Высший уровень (зависит от реализации)

1. Желаемая скорость тела.
1. Целевого позиции тела.
1. Желаемые параметры движений.

### Выходные порты

Поза робота (gait)

1. `ref_joints` (`JointState`) --- задающее воздействие в угловой системе координат, неполная поза.
1. `ref_limbs_cartesian` (`CartesianState`) --- задающее воздействие в декартовой системе координат.
1. `ref_support` (`SupportState`) --- ожидаемое распределение веса.

Поза робота (animation)

1. `ref_anim_joints` (`JointState`) --- задающее воздействие в угловой системе координат: хвост, уши.
1. `ref_eyes`--- задающее воздействие для глаз.


### Параметры

Параметры походки и анимаций, настраиваемые один раз при запуске.

1. `period` --- период дискретизации, должен совпадать с периодом таймера (опционален и избыточен: сообщения таймера хранят время).


### Плагины

1. Требует: плагин клиента [полситемы распределния ресурсов](components-resource-control) и предоставляемые им операции.

### Операции

**Выделение ресурсов:**

1. Предоставляет (опционально): `bool hookResourceChange()` --- пользовательский callbcak, вызываемый при изменении состава ресурсов. 
    Возвращает `true`, если компонент остается активен. 

### Интерфейс `actionlib`

**Поддержка нескольких целей**:

1. `goalCallback(GoalHandle)` ---  получить задание (цель движения, его параметры).
1. `cancelCallback(GoalHandle)` ---  прекратить исполнение задания.
2.  Извещения о завершении, отказе исполнения осуществялется средствами `actionlib` через взаимодействие с `GoalHandle`.
Управление набором `GoalHandle` и их сотояниями ложится на пользователя. 

**Одна цель**:

Предлагается использовать `ControllerOneGoalActionServer` аналог класса [`SimpleActionServer`](http://docs.ros.org/api/actionlib/html/classactionlib_1_1SimpleActionServer.html) полностью или частично скывающий от пользователя взаимодействия с `GoalHandle` и клиентом арбитра ресурсов.  Он он требет от пользовательского кода аналогичный набор callback.
1. `goalCallback(Goal)` ---  получить задание (цель движения, его параметры).
2. `cancelCallback()` ---  прекратить исполнение задания (опционально).
3.  `hookResourceChange()` 
При этом она устанавливает для клинета арбитра **свой** `hookResourceChange_impl()`, содержащий код по работе с `GoalHandle`.

### Семантика исполнения

После исполнения `configure` компонент готов к работе и запуску.

Переход к активному состоянию (формирует задающее воздействие) осуществляется вызовом `actionlib`, либо `start()` (эти механизмы исключают друг друга).
После вызова операции проводится проверка возможности активации в данном состоянии робота. 
В зависимости от результата формируется отказ (`goal->setRejected` или возврат `false`), либо создается запрос ресурсов.

Непосредственный переход в состояние активное состояние и запуск компонента происходит по подтверждению выделения ресурсов.

В активном исполняется основной код задатчика с периодом, определяемым таймером.
Значения времени и номера периода дискретизации переносятся из `TimerEvent` в выходные сообщения.

По завершению движения, либо по требованию освобождения ресурсов производится остановка выполнения.
Производится информирование высшего уровня средствами `actionlib` (цель достигнута/отвергнута), либо иным способом, если это требуется.

### Детали реализации.

Для компонентов на базе `actionlib` следует удалить операцию `start()` из внешнего интерфейса.

Состояния "запущен" и "активен" не тождественны. Неактивный компонент не посылает задающее воздействие,
независимо от его состояния, а остановленный компонент не обрабатывает сообщения.
Поэтому для обработки сообщений арбитра задатчик должен быть запущен. 
С другой стороны, остановленный задатчик не участвует в переключении контекстов.
Поэтому разумно запускать задатчик перед запросом ресурсов (из `goalCallback()`) и останавливать при деактивации (из `upadteHook`).

Пример взаимодействия с клиентским плагином арбитра ресурсов: [компонент переключения походок](components-resource-control).

Механизм плагинов в перспективе позволить усложнить протокол выделения ресурсов, не модифицируя сами компоненты задатчиков.
Также он избавляет программиста от необходимости проверять запросы на освобождение в каждой реализации задатчика.

**Класс `ControllerOneGoalActionServer`**

Цель этого класса инкапсулироваь код по взаимодействию с `GoalHandle` и клиентом арбитра, что
обеспечивающее гарантированное присутсвие в сотоянии "активен"  коректной цели, посылку уведомлений и т.п.

Класс реализует `goalCallback(GoalHandle)` и `cancelCallback(GoalHandle)` actionlib сервера, в которых содержится код по обработке  `GoalHandle` и вызов пользовательского callback, если нужно. Аналогично реализуется `hookResourceChange_impl()`.

Конкретный интерфейс надо уточнять, исходя из варинтов использования, как основу следует  [`SimpleActionServer`](http://docs.ros.org/api/actionlib/html/classactionlib_1_1SimpleActionServer.html). Потенциально в этот класс выносится весь код взаимодействия с `GoalHandle`.

### Исключения

Зависят от реализации.



