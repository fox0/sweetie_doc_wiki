Задатчики (походки, анимации)
=============================

Компонент формирует задающее воздействии для некоторого набора ресурсов.
Для части ресурсов --- зарегистрированных кинематических цепочек --- выдает желаемую позу в угловой или декартовой системе координат.
Для остальных ресурсов форма задания определяется типом.

Разрешение конфликтов ресурсов обеспечивается [арбитром и клипентским плагином](components-resource-control).

Способ взаимодействия с верхним уровнем не декларируется, но рекомендуется использовать `actionlib`.

Набор интерфейсов сильно зависит от назначения. Далее перечислены большинство возможных способов взаимодействия,
реальный компонент реализует только часть.

### Входные порты

Синхронизация

1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.

Текущее состояние робота

1. `joints_sorted` (`JointState`) --- состояние робота в угловой СК (желаемая или реальная по датчикам), отсортированная по кинематическим цепочкам.
1. `limbs_cartesian` (`CartesianState`) --- состояние робота в декартовой СК (желаемая или реальная по датчикам).
1. `support` (`SupportState`) --- показания датчиков касания.

Высший уровень (зависит от реализации)

1. Желаемая скорость тела.
1. Целевого позиции тела.
1. Желаемые параметры движений.

### Выходные порты

Поза робота (gait)

1. `ref_joints` (`JointState`) --- задающее воздействие в угловой системе координат, неполная поза.
1. `ref_limbs_cartesian` (`CartesianState`) --- задающее воздействие в декартовой системе координат.
1. `ref_support` (`SupportState`) --- ожидаемое распределение веса.

Поза робота (animation)

1. `ref_anim_joints` (`JointState`) --- задающее воздействие в угловой системе координат: хвост, уши.
1. `ref_eyes`--- задающее воздействие для глаз.


### Параметры

Параметры походки и анимаций, настраиваемые один раз при запуске.

1. `period` --- период дискретизации, должен совпадать с периодом таймера (опционален и избыточен: сообщения таймера хранят время).


### Плагины

1. Требует: плагин клиента [полситемы распределния ресурсов](components-resource-control) и предоставляемые им операции.

### Операции

Выделение ресурсов:

1. Предоставляет (опционально): `bool hookResourceChange()` --- пользовательский callbcak, вызываемый при изменении состава ресурсов. 
    Возвращает `true`, если компонент остается активен. 

Интерфейс `actionlib`:

1. `goalCallback` ---  получить задание (цель движения, его параметры).
1. `cancelCallback` ---  прекратить исполнение задания.
2. Извещения о завершении, отказе исполнения осуществялется средствами `actionlib`.

### Семантика исполнения

После исполнения `configure` компонент готов к работе и запуску.

Переход к активному состоянию (формирует задающее воздействие) осуществляется вызовом `actionlib`, либо `start()` (эти механизмы исключают друг друга).
После вызова операции проводится проверка возможности активации в данном состоянии робота. 
В зависимости от результата формируется отказ (`Goal Rejected` или возврат `false`), либо создается запрос ресурсов.

Непосредственный переход в состояние активное состояние и запуск компонента происходит по подтверждению выделения ресурсов.

В активном исполняется основной код задатчика с периодом, определяемым таймером.
Значения времени и номера периода дискретизации переносятся из `TimerEvent` в выходные сообщения.

По завершению движения, либо по требованию освобождения ресурсов производится остановка выполнения.
Производится информирование высшего уровня средствами `actionlib` (цель достигнута/отвергнута), либо иным способом, если это требуется.

### Детали реализации.

Для компонентов на базе `actionlib` следует удалить операцию `start()` из внешнего интерфейса.

Состояния "запущен" и "активен" не тождественны. Неактивный компонент не посылает задающее воздействие,
независимо от его состояния, а остановленный компонент не обрабатывает сообщения.
Поэтому для обработки сообщений арбитра задатчик должен быть запущен. 
С другой стороны, остановленный задатчик не участвует в переключении контекстов.
Поэтому разумно запускать задатчик перед запросом ресурсов (из `goalCallback()`) и останавливать при деактивации (из `upadteHook`).

Пример взаимодействия с клиентским плагином арбитра ресурсов: [компонент переключения походок](componentes-resource-control).

Механизм плагинов в перспективе позволить усложнить протокол выделения ресурсов, не модифицируя сами компоненты задатчиков.
Также он избавляет программиста от необходимости проверять запросы на освобождение в каждой реализации задатчика.

### Исключения

Зависят от реализации.



