Задатчики (походки, анимации)
=============================

Компонент формирует задающее воздействии для некоторого набора ресурсов.
Для части ресурсов --- зарегистрированных кинематических цепочек --- выдает желаемую позу в угловой или декартовой системе координат.
Для остальных ресурсов форма задания определяется типом.

Разрешение конфликтов ресурсов обеспечивается [арбитром и клипентским плагином](components-resource-control).

Способ взаимодействия с верхним уровнем не декларируется, но рекомендуется использовать `actionlib`.

Набор интерфейсов сильно зависит от назначения. Далее перечислены большинство возможных способов взаимодействия,
реальный компонент реализует только часть.

### Входные порты

Синхронизация

1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.

Текущее состояние робота

1. `joints_sorted` (`JointState`) --- состояние робота в угловой СК (желаемая или реальная по датчикам), отсортированная по кинематическим цепочкам.
1. `limbs_cartesian` (`CartesianState`) --- состояние робота в декартовой СК (желаемая или реальная по датчикам).
1. `support` (`SupportState`) --- показания датчиков касания.

Высший уровень (зависит от реализации)

1. Желаемая скорость тела.
1. Целевого позиции тела.
1. Желаемые параметры движений.

### Выходные порты

Поза робота (gait)

1. `ref_joints` (`JointState`) --- задающее воздействие в угловой системе координат, неполная поза.
1. `ref_limbs_cartesian` (`CartesianState`) --- задающее воздействие в декартовой системе координат.
1. `ref_support` (`SupportState`) --- ожидаемое распределение веса.

Поза робота (animation)

1. `ref_anim_joints` (`JointState`) --- задающее воздействие в угловой системе координат: хвост, уши.
1. `ref_eyes`--- задающее воздействие для глаз.


### Параметры

Параметры походки и анимаций, настраиваемые один раз при запуске.

1. `period` --- период дискретизации, должен совпадать с периодом таймера (опционален и избыточен: сообщения таймера хранят время).


### Плагины

1. Требует: плагин клиента [полситемы распределния ресурсов](components-resource-control) и предоставляемые им операции.

### Операции

**Выделение ресурсов:**

1. Предоставляет (опционально): `bool resourceChangeHook()` --- пользовательский callbcak, вызываемый при изменении состава ресурсов. 
    Возвращает `true`, если компонент остается активен. 

### Интерфейс `actionlib`

**Поддержка нескольких целей**:

1. `goalCallback(GoalHandle)` ---  получить задание (цель движения, его параметры).
1. `cancelCallback(GoalHandle)` ---  прекратить исполнение задания.
2.  Извещения о завершении, отказе исполнения осуществялется средствами `actionlib` через взаимодействие с `GoalHandle`.
Управление набором `GoalHandle` и их сотояниями ложится на пользователя. 

**Одна цель**:

Предлагается использовать `OrocosSimpleActionServer` аналог класса [`SimpleActionServer`](http://docs.ros.org/api/actionlib/html/classactionlib_1_1SimpleActionServer.html),
скывающий от пользователя взаимодействия с `GoalHandle` и клиентом арбитра ресурсов.  Он требет от пользовательского кода аналогичный набор callback.
1. `newGoalHook(Goal)` ---  получить задание (цель движения, его параметры).
2. `cancelGoalHook()` ---  прекратить исполнение задания (опционально).
3.  `resourceChangeHook()` 

### Семантика исполнения

После исполнения `configure` компонент готов к работе и запуску.

Переход к активному состоянию (формирует задающее воздействие) осуществляется вызовом `actionlib`, либо `start()` (эти механизмы исключают друг друга).
После вызова операции проводится проверка возможности активации в данном состоянии робота. 
В зависимости от результата формируется отказ (`goal->setRejected` или возврат `false`), либо создается запрос ресурсов.

Непосредственный переход в состояние активное состояние и запуск компонента происходит по подтверждению выделения ресурсов.

В активном исполняется основной код задатчика с периодом, определяемым таймером.
Значения времени и номера периода дискретизации переносятся из `TimerEvent` в выходные сообщения.

По завершению движения, либо по требованию освобождения ресурсов производится остановка выполнения.
Производится информирование высшего уровня средствами `actionlib` (цель достигнута/отвергнута), либо иным способом, если это требуется.

### Детали реализации.

Для компонентов на базе `actionlib` следует удалить операцию `start()` из внешнего интерфейса.

Состояния "запущен" и "активен" не тождественны. Неактивный компонент не посылает задающее воздействие,
независимо от его состояния, а остановленный компонент не обрабатывает сообщения, включая сообщения `actionlib`.
Поэтому для обработки сообщений арбитра и `actionlib` задатчик должен быть запущен, 
либо такая обработка должна быть явно разрешена из `dataOnPortHook()` путем возврата `true` для соответсвующих портов (не таймер, имеет пользовательский callback).

Слишком большое число одновременно запущенных задатчиков может вызвать проблемы.
Поэтому разумно запускать задатчик перед запросом ресурсов (из `goalCallback()`) и останавливать при деактивации (из `upadteHook`).
Однако первичные реализации можно делать на база постоянно запущенных задатчиков.

Пример взаимодействия с клиентским плагином арбитра ресурсов: [компонент переключения походок](components-resource-control).

Механизм плагинов в перспективе позволить усложнить протокол выделения ресурсов, не модифицируя сами компоненты задатчиков.
Также он избавляет программиста от необходимости проверять запросы на освобождение в каждой реализации задатчика.

### Исключения

Зависят от реализации.

## `OrocosSimpleActionServer` 

Класс-обертка для исходной реализации `ActionServer` для OROCOS. Поддерживает работу с одной целью, скрывает сложности взаимодействия с `GoalHandler`.
Принцип-работы близок к `SimpleActionServer` ROS в режиме с Callback. Сотояния цели не тождественны сотояниям задатчика. 

### Интерфейс

0. `start`/`stop`/`addPorts` --- запуск, остановка, добавление портов.
1. `bool isActive()` --- присутствует ли активная цель.
2. `bool isPending()` --- присутствует цель, ожидающая активации.
3. `boost::shared_ptr<const Goal> getActiveGoal()` --- возвращает активную цель, если есть.
3. `boost::shared_ptr<const Goal> getPendingGoal()` --- возвращает ожидающую активации цель, если есть.
3. `void acceptPending(Result result)` --- принять ожидающую активации цель, ничего не делает, если такой цели нет. Меняет статус активной цели (если есть) на "прервана" (preemted) с результатом `result`.
3. `void rejectPending(Result result)` --- отклонить ожидающую активации цель, ничего не делает, если такой цели нет.
3. `void abortActive(Result result)` --- прервать (aborted) выполнение активной цели, ничего не делает, если такой цели нет.
3. `void succeedActive(Result result)` --- завершить выполнение активной цели, ничего не делает, если такой цели нет.
3. `void setGoalHook(boost::function< void()> newGoalHook)` --- функция будет вызываться при появлении новой (pending) цели.
3. `void setCancelHook(boost::function< void()> cancelGoalHook)` --- функция будет вызываться при отмене активной цели.

Вариант: функции типа `accept`/`reject` возвращают `true`, если совершают действие, иначе --- `false`. Это позволяет уменьшить число проверок.

### Семантика исполнения

Одновременно может две цели: активную и ожидающую активации.  Активная цель всегда одна. Ожидающая активации заменяет ее по вызовы `acceptPending()`.
Ожидающая цель тоже одна. Новая цель отменяет текущую ожидающую и занимает ее место. По этому событияю вызывается `newGoalHook`.

Одновременно на `OrocosSimpleActionServer` ложатся базовые проверк состояния целей, формирование отладочных сообщений о смене цели.

### Пример использования

Пример использования: все цели требуют одникового набора ресурсов. 
Предполагается, что комонент всегда находится в сотоянии `Running`.

    void newGoalHook(pending_goal) {
        if (! условия исполнеия для pending_goal) {
            as.rejectPending(не выплнены условия запуска);
            return; //выполнеие активной цели, если была, продолжается
        }
        if (isOperational() && hasResources(нужные ресурсы)) {
            as.acceptPending(прервана другой целью); % заменяем одну цель на другую без запроса ресурсов.
    	}
    	else {
            rc.startOperational(нужные ресурсы); // запрос набора ресурсов.
        }
    }
    
    bool resourceChangeHook() {
        if (hasResources(нужные ресурсы) {
            if (as.isPending()) {
                as.acceptPending(прервана другой целью); // прерываем активную цель, если была
                операции по запуску новой цели
            }
    		return true; 
        }
        else {
            rejectPending(нет ресурсов);
    		if (as.isActive()) {
                 операции по рекращению работы
                 as.abortActive(отобраны ресурсы);
            }
            return false;
        }
    }
    
    void cancelGoalHook() {
        операции по рекращению работы
        as.abortActive(отменена);
        stopOperational();
    }
            

