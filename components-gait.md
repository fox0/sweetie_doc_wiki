Задатчики (походки, анимации)
=============================

Компонент формирует задающее воздействии для некоторого набора ресурсов.
Для части ресурсов --- зарегистрированных кинематических цепочек --- выдает желаемую позу в угловой или декартовой системе координат.
Для остальных ресурсов форма задания определяется типом.

Задатчики имеют встроенную подсистему переключения (захвата ресурсов).

Способ взаимодействия с верхним уровнем не декларируется, но рекомендуется использовать `actionlib`.

Набор интерфейсов сильно зависит от назначения. Далее перечислены большинство возможных способов взаимодействия,
реальный компонент реализует только часть.

### Входные порты

Синхронизация

1. `sync` (`TimerEvent`, EventPort) --- синхронизация таймера.

Текущее состояние робота

1. `joints`/`limbs_joints` (`JointState`/`JointLimbState`) --- состояние робота в угловой СК (желаемая или реальная по датчикам).
1. `limbs_cartesian` (`CartesianState`) --- состояние робота в декартовой СК (желаемая или реальная по датчикам).
1. `support` (`SupportState`) --- показания датчиков касания.

Высший уровень (зависит от реализации)

1. Желаемая скорость тела.
1. Целевого позиции тела.
1. Желаемые параметры движений.

### Выходные порты

Поза робота (gait)

1. `ref_joints` (`JointState`/`JointLimbState`) --- задающее воздействие в угловой системе координат.
1. `ref_limbs_cartesian` (`CartesianState`) --- задающее воздействие в декартовой системе координат.
1. `ref_support` (`SupportState`) --- Ожидаемое распределение веса (или не `(?)`

Поза робота (animation)

1. `ref_anim_joints` (`JointState`/`JointLimbState`) --- задающее воздействие в угловой системе координат: хвост, уши.
1. `ref_eyes`--- задающее воздействие для глаз.


### Параметры

Параметры походки и анимаций, настраиваемые один раз при запуске.

1. `period` --- период дискретизации, должен совпадать с периодом таймера (опционален и избыточен: сообщения таймера хранят время).

### Операции

Запрос/выделение ресурсов (реализованы в [классе-родителе](componentes-resource-control)):

1. Предоставляет: `releaseResources`
1. Требует: `requestExclusiveResources`

Интерфейс `actionlib`:

1. Получить задание (цель движения, его параметры).
1. Прекратить исполнение задания.
2. Средства извещения о завершении, отказе исполнения.

### Семантика исполнения

После исполнения `configure` компонент готов к работе и запуску.

Переход к активному состоянию (формирует задание) осуществляется вызовом `actionlib`, 
либо `start()` (эти механизмы исключают друг друга).
После вызова операции проводится проверка возможности активации в данном состоянии робота. 
В зависимости от результата формируется отказ (`Goal Rejected` или возврат `false`), либо создается запрос ресурсов.

Непосредственный переход в состояние активное состояние и запуск компонента происходит по подтверждению выделения ресурсов.

В активном исполняется основной код задатчика с периодом, определяемым таймером.
Значения времени и номера периода дискретизации переносятся из `TimerEvent` в выходные сообщения.

По завершению движения, либо по требованию освобождения ресурсов производится остановка выполнения.
Производится информирование высшего уровня средствами `actionlib` (цель достигнута/отвергнута),
либо иным способом, если это требуется.

**Замечание**: состояния "запущен" и "активен" не тождественны. Единственное ограничение --- неактивный компонент не посылает задающее воздействие,
независимо от его состояния.  Конкретные отношения --- усмотрение разработчика. Но надо помнить, что остановленный компонент не обрабатывает сообщения.

<!--компонент сам управляет своим исполнение (вызывает `start()/stop()`). Такое соглашение 
позволяет реализовать другую семантику исполнения (например, компонент всегда запущен).-->

### Детали реализации.

Для компонентов на базе `actionlib` сдледует удалить операцию `start()` из внешнего интерфейса.

Компоненты задатчиков является наследником класса `ResourceControl::ResourceConsumer`, см. [компонент переключения походок](componentes-resource-control).
Там же описан механизм взаимодействия с кодом задатчика (`requestExclusiveResources()`, `notifyResourcesAcquire()`, `notifyResourcesRelease()` и пр.)
<!---Запрос ресурсов осуществлялется вызовом `bool requestExclusiveResources(const strings& resourses)`, 
при приходе требования о освобождении вызовется метод `notifyResourcesRelease()` (реализуется в наследнике), 
при успешном захвате ресурсов `notifyResourcesAcquire()`.-->

Такой механизм в перспективе позволить усложнить протокол выделения ресурсов, не модифицируя сами компоненты задатчиков.
Также он избавляет программиста от необходимости проверять запросы на освобождение в каждой реализации задатчика.


### Исключения

Зависят от реализации.


Список задатчиков
-----------------

**Замечание**: Список имеет смысл раширить, дополнить и выделить в отдельную страницу, снабдить именами.

### Походки

* Движение шагом с заданной скоростью и радиусом кривизны.
* Свободная походка.
* Стать на месте.


### Анимации

* Трансляция сообщений `JointState` от `rviz`.
* Управление заданной ноги с джойстика в декартовой СК. Интерфейс джойстика --- отдельный компонент.
* Проиграть движение из файла.
* Типовые движения: лечь, сесть, встать, помахать копытом.



