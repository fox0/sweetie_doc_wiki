Развертывание системы
=====================

(Новая версия. Старая доступна [тут](deployer-old.md)).

Конфигурация развернутой системы описывается тремя элементами:

1. Загруженные компоненты.
1. Параметрами всех компонент.
2. Отношениями между компонентами (соединения портов и операций). 

OROCOS компоненты могут иметь скрытые параметры, не представленные в их внешних интерфейсах как `Properties`.
Изменять их можно, например, вызовом операций. *Таких ситуаций следует избегать*, т.к. такие настройки не 
будут видимы стандартным средствам ROS/OROCOS.

В ROS отношения компонент представлены набором сервисов и топиков.

Общие идеи работы системы 
-------------------------

На уровне ROS система представлена набором `roslaunch` скриптов. На уровне OROCOS --- `lua` скрипты развертывания. 
Каждый из скриптов 
* представляет собой законченный модуль, добавляющий в систему законченную функциональность с четко детеминированным интерфейсом (порты, топики, сервисы),
* зависит от других модулей 
* инвариантен по отношению пространств имен, где запускается (необходимо для поддержки виртуального и реального робота).

Параметры развертывания хранатяся в `yaml` файлах (для последующей загрузки в Parameter Server ROS), `cpf` используется как исключение, где применени `yaml` невозможно.
Жесткое назначение парамеров внутри модулей развертки не верхнего уровня неприемлемо.  

Способ хранения статических и медленном меняющи данных (парметры, траекторий) должен гарантировать их целостность во всей системе при использовании нескольких машин. 
В этом случае хранение в файлах не эффективно: необходимо синхронизоват содеримое ФС перед каждым обращением.                       

В настоящий момент система одномастерная (один `roscore`), однако перспективной выглядит использование многомастерной схемы (требуется дополнительное исследование).
* В одномастеной системе целостность всех настроек и данных достигатся за счет использование сервера параметров ROS. 
* В многомастеной для синхронизации серверов параметров перед запуском используется mongodb [`config_manager`](http://wiki.ros.org/mongodb_store), 
    в процессе работы содержимое параметров не должно меняться. Она же использеутся как централизированное хранилище данных (траектории).

Предполагается наличие в развернутой системе двух машин:
* Компьютер робота (Rashberry Pi или Beagle Board) исполняет подсистему управдления движением, код анимации глаз и звука. В опреленных конфигурациях может работать автномно.
* Управляющий компьютер (компьютер оператора, ПК) запускает виртуального робота (часть подсистемы движения), графические системы мониторинга и управления движением (rviz, интерфейс flexbe).
     На эту же машину могут быть вынесен высший уровен управления, сложные операции по обаботке изображений, SLAM и т.п. 

Пространства имен
-----------------

Правила именования изложены в [общих соглашениях](common.md). Ниже приводится сема пространств имен ROS с загруженной подсистемой OROCOS

   +- sweetie_bot
   |   +- motion (нода rttlua, OROCOS)
   |   |   +- resource_control/arbiter
   |   |   +- agregator_ref (компонент, публикует желаемую позу)
   |   |   +- servo_inv
   |   |   +- herkulex/array (компонент)
   |   |   +- agregator_real (компонент, публикует реальную позу)
   |   +- eyes (нода глаз или пространство с нодами глаз)
   |   +- robot_state_publisher
   |   +- flexbe_engine (на управляющей машине или на роботе)
   +- sweetie_bot_virtual
   |   +- motion (нода rttlua, OROCOS)
   |   |   +- resource_control/arbiter
   |   |   +- agregator_ref
   |   |   +- controller/gait
   |   +- robot_state_publisher
   |   +- moveit_group
   +- hmi
       +- rviz
       +- joint_trajectory_editor


Обе основные ветки `sweetie_bot` и `sweetie_bot_virtual` содержат идентичные развернутые системы управления, отличающиеся только уровнем взаимодествия с оборудованием.
Все топики дублируются внутри этих пространств. Такая схема наиболее удоба для последующего перехода на вариант с несколькими мастерами.

Компоненты `sweetie_bot` запускаются на роботе, однако отдельные элементы этого пространства (`moveit`, `flexbee_engine`) могут быть выненсены на машину оператора.
Компоненты `sweetie_bot_virtual` и `hmi` запускатся на машине оператора. Поддержки запуска `hmi` на строне робота не требуется.

### Идентификаторы систем координат

ROS требует уникальности идентификаторов систем координат в рамках одного roscore. Топик `\tf` полагается глобальным, `rviz` не поддерживаетиспользование нескольких `\tf`.

Чтобы преодолеть эти сложности предлагается следующая стратегия (проект, надо проверить работоспособность `move_group` и соответвующего модуля `rviz`):

1. Внутри `sweetie_bot_virtual` и `sweetie_bot` все глобальные топики дублируются при помощи `remap`. Соответвенно появлется свой `tf`, `tf_static` и т.п. 
    Внутри заускается полная инфраструктура, в частности `robot_state_publisher`, публикующий позу в локальный топик `tf` **без каких-либо префиксов**.
    Здесь же развертываются подсистемы `moveit` одометрии и т.п.
2. Вне этих пространств имен запускается еще пара `robot_state_publisher` (или транзитные ноды), добавляющая к сообщениям локальных `tf` нужные префиксы: `real` и `virtual`.

Сложность может вызвать запуск в `rviz` плагина `moveit`, т.к. не ясно, как он будет воспринимать префиксы. В этом случае придется убирать один из префиксов (`real`, `virtual`)
в зависимости от того, где запущена `move_group`.

Система развертывания
-------------------

Система развертывания представлена набором пакетов в каталоге `deployment`:
* `sweetie_bot_deploy` --- базовая подсистема развертывания.
* `sweetie_bot_movit_config`  --- конфигурация `moveit!`.
* `sweetie_bot_test` --- средства тестирования подсистем, требующих развертки значительной части СУ робота.
* `sweetie_bot_deploy_...` --- дополнительны средсва развертки для новых подсистем.

`sweetie_bot_deploy` предоставляет средства для запуска системы. 

### Скрипт `config.lua` и `sweetie-bot-core`

Центральным его элементом является скрипт `common/config.lua`, предназанченный для запуска нужной конфигурации OROCOS.
     
         rttlua config.lua <module1>.lua <module2>.lua> ... <overlay1> <overlay2> ... __ns:=<namespace> __name:=<name>

Скрипт выполняет следующие дествия:

1. Разрешает параметры `<overlayX>` в имена каталогов. Если путь относительный, то к нему добавляется префикс пакета `sweetie_bot_deploy`, иначе используется переданный путь.
    К полученному добавляются `<sweetie_bot_deploy_pkg>/common` и `<sweetie_bot_deploy_pkg>`

2. Добавляет полученный список каталогов к `LUA_PATH`, `<overlay1>` идет будет первым, затем `<overlay2>` и т.д.

3. Загружает необходимое окружение RTT: модули `rosnode`, `rosparam`, `rttlib_extra`, объявляет глобальные переменные `depl` (Deployer), `ros` (сервис ROS).

4. Имя ноды `<name>` и `<namespace>` используется для назначения параметра `default_root_category` сервиса `log4cpp`.

5. Предоставляет функцию `config.file`, которая ищет файл по имени последовательно в `<overlay1>`, `<overlay2>` и т.д.

6. Последовательно загружает `<moduleX>` командой `require`.

Ряд полезных переменных попадет в таблицу `config`: список модулей, оверлеев, категория логгера и т.п.

Для удобства использование этого скрипта его вызов инкапсулирован в скрипт bash `sweetie-bot-core`:

    sweetie-bot-core <module1>.lua <module2>.lua> ... <overlay1> <overlay2> ... __ns:=<namespace> __name:=<name>

### Использование скрипта развертки OROCOS

Развертка осуществляется при помощи модулей lua и конфигурационных файлов:

    sweetie_bot_deploy
     |- sweetie-bot-core --- скрипт bash для запуска config.lua
     |- common --- скрипты и конфигурация общего назначения
     |   |- config.lua --- главный скрипт развертки
     |   |- rttlib_extra.lua --- библиотека вспомогательных функций (обращение к rosparam, упрощение назначения сложных параметров и т.п.)
     |   |- reporting.lua --- функции загрузки и подключения `OCL::ReportingComponent`
     |   |- logger.lua
     |   \- logger.log4cpp
     |- motion_core
     |   |- resource_arbiter.lua, resource_control.yaml
     |   |- motion_core.lua --- арбитр и агрегатор (минимальный набор).
     |   |- motion.lua --- арбитр и агрегатор и подсистема управления приводами.
     |   |- virtual_motion.lua --- ядро для симуляции.
     |   \- herkulex_feedback.lua, herkulex_feedback.yaml, sweetie_bot_servos.cpf --- подсистема Herkulex.
     |- joint_space_control --- задатчики, работающие в угловой СК.
     |   |- controller_joint_state.lua --- контроллер `FollowJointState`.
     |   |- controller_joint_trajectory.lua --- контроллер `AnimationJointTrajectory`.
     |   |- controller_joint_space_all.lua --- все контроллеры.
     |   \- controller_joint_space.yaml --- парметры.
     ... 

Модули подчиняются общим соглашениям:

1. Устанавливают между собой зависимости посредством `require`. Это позволяет загружать один модуль не более одного раза, независимо от того, сколько раз вызывалось `require`.

2. Загружают соответвующие компоненты, устанавливают параметры используя процедуру из `rttlib_extra`, соединяют порты. 
    Благодаря вызову `require` можно считать, модули, от которых зависит данный уже загружены.

3. Создают переменную lua, по которой легко обращаться к загруженному компонету (`agregator_ref`, `servo_inv` и т.п.). 
    Имя переменной совпадает с именем компонента без префикса (см. [общие соглашения](common.md)).

    Отдельне модули (`resource_control`, задатчики) в соответвие со схемой имнования помещают переменные компонента в таблицу, играющую роль пространства имен:
        
        herkulex.array
        herkulex.sched
        resource_control.arbiter
        
    В этой же таблице могут присутсвовать вспомогательные переменные и функции модуля.

3. Для обращения к конфигурационным файлам (`.log4cpp` и `.cpf`) используют `config.file()`. Это позволяет замещать фалы при помощи механизма overlay.

4. Для обращения к не входящим в оверлеи модулям можно использовать нотацию `require "<overlay>.<module>"`. См. документацию lua к команде `require`.

5. По завершению выполнения модуля соответвующая подсистема должна быть в работоспособном состоянии.

Типовой вызов выгдядит так:

    sweetie-bot-core controller_joint_state.lua motion.lua joint_space_control motion_core

Он загружает один контроллер и полситему управления реальным роботом. Для успешного запуска все необходимые параметры должны быть загружены из yaml в сервер параметров.

### Параметры ROS, топики ROS

Для каждого компонента следует загружать конфигурацию из сервера параметров, используя вызов `rttlib_extra.get_peer_rosparam()`.
Он обращается к Parameter Server, используя пространство имен вида (см. [общие соглашения](common.md)):

    <namespace>/<nodename>/<component_name>
    <namespace>/<nodename>/<subsystem>/<component_name>

Топики ROS, связанные с компонетаи OROCOS, располагаются в том же пространстве имен. Их имена совпадают с именами портов.

### Скрипты `launch`

Скрипты `launch` разамещаются в тех же каталога-оверлеях, в завсимости отпринадлежности к той или иной подсистемы.
Принципиально они могут быть двух типов:
1. Модули, подобно модулям развертки OROCOS, загружающие некую хорошо определнну часть системы. Обладают свойством универсальности, что позволяет их задействовать в любой части системы.
    Их можно разделить на две группы: 
        * Модули робота, которые могут быть запущены в `sweetie_bot` или `sweetie_bot_virtual`, соответвенно на самом роботе и на машине оператора. 
             Они не должны сильно зависить от того, что вне их пространства имен.
        * Модули машины оператора, которые запускаются вне `sweetie_bot` и `sweetie_bot_virtual` и соответвенно видеть эти два пространства имен.

2. Скрипты высокого уровня. Они загружают нужный набор параметров и модулей, включая запуск подсистемы OROCOS на на роботе или компьютере оператора.

Модули реализующие функциональность робота должны быть инвариантны по отношению к базовому пространству имен: `sweetie_bot` или `sweetie_bot_virtual`.
В целях эффективного повторного использования кода парамеры из `yaml` файлов должны загружаться в модулях как можно более высокого уровня.

### Хранение параметров

Праметры хранятся в YAML файлах в каталогах оверлеев по подсистемам:

    sweetie_bot_deploy
     |- motion_core
     |   |- resource_control.yaml
     |   |- motion.yaml
     |   \- herkulex_feedback.yaml
     |- joint_space_control
         \- controller.yaml
	
Непосредственно кнфигурация робота хранится без префикса `sweetie_bot`/`sweetie_bot_virtual`.

Переход на `mongodb` может поребовать централизации `yaml` файлов в одном каталоге. 
Более удобен был бы вариант с оверлеямаи, когда последовательно загружается несколько `.yaml` файлов из указанных в `roslaunch` каталогов.
(Нужен будет небольшой патч к `config_manager`.

### Дополнительные пакеты развертывания

Средства `sweetie_bot_deploy` могут очевидным образом использоваться из других пакетов. 
Таким образом можно легко разбивать подсистему конфигурации на большие модули по назначению.


Использование нескольких `roscore`
---------------------------------

Наиболее надежную систему можно получив, развернум несколько `roscore`: одно на роботе, другое на управляющем компьютере (http://wiki.ros.org/sig/Multimaster/Existing Techniques).

Единственный стабильный механизм (http://wiki.ros.org/multimaster_fkie) позволяет видеть топики и сервисы другого roscore, что достаточно, чтобы создавать единое рабочее пространство.
Некоторую сложность представляет синхронизация параметров. Эту возможность предоставляет `config_manager` из [`mongodb_store`](http://wiki.ros.org/mongodb_store).




Обсуждение возможностей развертки 

Параметры предназначены для настройки компонент, входящих в систему.  Они назначаются до запуска компонент, в процессе работы меняются редко. 

**Статические параметры** --- параметры состав которых и типы заранее фиксированы (скорость передачи днанны, имя файла). 

**Динамические параметры** --- состав параметров (древовидная структура) при написании компонента (список и параметры приводов).

### Пространство имен параметра

Оределяется областью его действия:

1. `/sweetie_bot/robot_description` (модель робота) --- уровень робота,
2. `/sweetie_bot/motion/period` (частота дискреттизации) --- уровень подсисткмы управления движением.
3. `/sweetie_bot/motion/herkulex_driver/baudrate` --- параметр конкретного компонета.

Для компонент OROCOS имя параметра контруируется следущим образом (в соответствие с сервисом [`rosparam`](https://github.com/orocos/rtt_ros_integration/tree/indigo-devel/rtt_rosparam)):

   <полное имя ноды развертки>/<имя компонента>/<имя параметра> 

Для получения параметров используются операции `rosparam`:

* `getRealative("param")` --- ищет "/sweetie_bot/param" (относительный путь, пространство имен, где запущен OROCOS) 
* `getPrivate("param")` --- ищет "~param", точнее "/sweetie_bot/motion/param" (приватное пространство имен OROCOS) 
* `getPrivateСomponnent("param")` --- ищет "~<component_name>/param", точнее "/sweetie_bot/motion/<component_name>/param" (приватное пространство компонента OROCOS) 
* `getAbsolute("param")` --- ищет "/param" (абсолютный путь), не рекомендуется.

### Способ хранения параметров

1. Динамических параметры хранятся в `.cpf` файлах OROCOS. 
    (Иного способа нет, `rosparam` не поддерживает динамическую загрузку, но можно написать к нему патч).
    
    Именами, ответствуют компоненту или его типу. Т.к. `.cpf` --- это XML формат, то можно использовать включение файла по URI (в частности по относительному пути от включающего `.cpf` файла).
    Общую конфигурацию для нескольких компонент следует выделять в отдельный файл.
2. Статические параметры можно хранить как угодно:
    * `.yaml` при соблюдении правил именования. Загрузка: `.yaml` -> `Parameter Server` -> `rosparam.getAll()` (Cм. [`rosparam`](https://github.com/orocos/rtt_ros_integration/tree/indigo-devel/rtt_rosparam)).
    * `.cpf`. Загрузка: `marshalling.updateProperties()` (менее предпочтительно)
    * Скрипты развертывания (менее предпочтительно). Для получения параметра в скрипте lua можно воспольщзоваться `rttlib_extra.rosparam_get_string` (часть системы развертки).
3. Модификация параметров
    * Скрипты при загрузке, штатные средства 
    * [`dynamic_reconfigure`](http://wiki.ros.org/dynamic_reconfigure) через [`rtt_dynamic_reconfigure`](https://github.com/orocos/rtt_ros_integration/tree/indigo-devel/rtt_dynamic_reconfigure)
4. Мониторинг:
    * [`rqt_reconfigure`](http://wiki.ros.org/rqt_reconfigure)
5. Сохранение конфигурации
    * Для статических можно также использовать `.yaml`, `rosparam dump`
    * `.cpf`, `marshalling.storeProperties()`

**Таким образом предпочитаемый способ хранения --- `.yaml`. 
Для загрузки параметров и нужных сервиов в компонент OROCOS рекомендуется использовать `rttlib_extra.rosparam_get_properties()` (часть системы развертки).**
Данная функция загружает нжные сервисы и использует приватное пространство имен компонента OROCOS для инициализации.

Пример использования параметров: `param_tester`. 

### Обработка параметров

Иногда по параметрам компонент создает некие вспомогательные структуры. Например, по декларациям кинематических цепочек создается массив их описаний структурами KDL.
Предлагается следующее соглашение:

1. Создание структур происходит в `configureHook()` их очистка в `cleanupHook()`.
    Таким образом, изменение соответствующих параметров работающего компонента не влияет на его функционирование.

2. Если необходима возможность перенастройки работающего компонента --- реализовать операцию `notifyPrpertiesUpdate()` (OwnThread) в 
    соответствии с [`rtt_dynamic_reconfigure`](https://github.com/orocos/rtt_ros_integration/tree/indigo-devel/rtt_dynamic_reconfigure) (Обратите внимания, в документации этот метод назван неправильно).

Развертывание системы
---------------------

OROCOS предоставляет различные средства развертывания:

* **`.xml`** описание. 
* **`.ops`** скрипты. 
* **`.lua`** скрипты

`.xml` --- эквивалент `roslaunch`. В обоих случаях, похоже, нет возможности исполнять операции. 
Поэтому конфигурация плагинов ROS будет затруднена. Нет доступа к окружению и `rospack`.
Однако этот способ более удобен для больших проектов за счет автоматизации ряда действий.
В принципе, недостатки можно исправить за счет вызова скриптов.

`.ops` предоставляет наиболее полный и наглядный способ развертки. 
Плагин `rtt_rospack` предоставляет средство определения путей пакетов, `os` к переменным окружения.
Не хватает некоторой функциональности: выразительности языка, средств работы с файлами (рабочий каталог, проверка существования),
автоматизации ряда процедур (например, запустить все), получения списка загруженных компонент.

Недостатки можно устранить, написав несколько вспомогательных скриптов. Для работы с ФС потребуется сервис.

`.lua` наиболее выразительна (полноценный язык) но хуже документирована.

Методы могут смешиваться в любой пропорции. Из любого описания можно вызвать любое.

**В качестве основного способа предлагается использовать скрипты `.ops`.**

*Проблемы*: нет средств работы работы с файлами, пакетного применения одной операции к группе компонент.

Конфигурация системы
--------------------

Полная конфигурация подсистемы движения размещается отдельном пакете. 
Такой пакет может содержать несколько связанных конфигураций.

Каталог с конфигурацией имеет структуру:

    |- properties/
    |   |- component1.cpf --- параметры 
    |   \- component2.cpf --- параметры
    |- core.ops --- базовый файл конфигурации, запускается для развертывания
    |- core_include1.ops --- часть базовой конфигурации, 
    |- component1.ops --- специфичная конфигурация компонента, вызывается из core.ops
    |- supplemental_action1.ops --- скрипт выполнения некого вспомогательного действия
    \- supplemental_action2.ops --- скрипт выполнения некого вспомогательного действия

В пакетах, реализующих компоненты можно хранить примеры конфигурации, но излишнее 
дублирование нежелательно.

*Проблема*: неясно, как управлять рабочим каталогом `deployer`.


### Вспомогательны скрипты

Предлагается выделить общие действия в виде отдельных функций или скриптов. 
Например, над компонентами задатчиков всегда совершаются одни и те же действия.

Для обращения к компоненту по имени можно использовать следующий код:

    aliasPeer("Deployer", name, "peer");
    peer.action();
    ... 
    removePeer("peer");


### Повторное использование конфигурации

Желательна возможность создания новой конфигурации по базовой путем замены `core.ops` и модификации небольшого числа параметров через `.cpf` или скрипты.
При этом модифицированная версия должна содержать только измененные файлы. 

Наиболее прямая реализация --- использование символьных ссылок. Более изящная требует операцию проверки существования файла.


